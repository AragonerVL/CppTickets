<details>
<summary>
 Template Ticket
</summary>


**жирный текст** _курсив_ ~~ошибка~~ ==мнения?== `inline code block` [ссылка на фулл](https://www.markdownguide.org/cheat-sheet/)
```c++
int main() {
    return 0;
}
```

### Подзаголовок

LMAO
Not bottom text, lol
</details>

<details>
<summary>
 4. Функции
</summary>

* ## Параметры
  * ### Синтаксис (пропущенное имя, значение по умолчанию в объявлении/определении)  
  У функции есть объявление и определение, хотя обычно они пишутся сразу вместе. У функции есть тип, название, в круглых скобках передаются параметры, в фигурных само тело функции.  
  ```C++
  void foo(int a, int b){}
  void foo(vector v = {1, 2, 3}){} // параметр по умолчанию
  ```
  Вот так будет выглядеть, если хотим разделить объявление и определение.  
  ```C++
  void foo(int a, int b);
  void foo(int a, int b){
     return a + b;
  }
  ```
  Это может быть полезно, например когда мы хотим использовать две функции друг в друге. При этом одна из них будет определена всегда равньше другой, поэтому приходится придегать к `Forward decloration`. То есть мы говорим, что такая функция есть, и мы можем её вызывать, но вот её определение мы попозже напишем.
  ```C++
  int bar(int x);
  int foo(int y){
      return bar(y - 1) + 1; // OK
  }
  int bar(int x){
      if(x <= 0) return 1;
      return foo(x - 1);
  }
  ```
  Ещё один случай, когда у нас есть несколько единиц трансяции. В этом случае там так же иногда приходится использовать функцию в единице трансляции отличной от той, где мы собственно эту функцию определяем. Поэтому приходится в каждой отдельной единице трасляции писать объявление, если мы хотим использовать функию.  
  Можно в качестве параметра использовать агрумент без имени, указав только его тип. Это, например, используется, чтобы различять префиксный и постфиксный декриметны и инкременты. Обратиться к переданному таким образом аргументу внутри функции не получится. При этом распалагать их можно в перемешку с обычными аргументами, но до агрументов со значениями по умолчанию.  
  ```C++
  void foo1(int a, int, int b, int, int, int c = 100){} // OK
  void foo2(int a, int, int b, int, int, int c = 100, int){} // Compilation error
  void foo3(int a, int, int b, int, int, int c = 100, int = 1){} // OK
  ```
  Аргументы со значениями по умолчанию всегда идут после всех остальных. Можно передавать им новые значения при вызове функции. Задать значение по умолчанию можно как в объявлении, так и в определении функции, но только либо там, либо там.
  ```C++
  void foo1(int c = 100);
  void foo1(int c){
    std::cout << c; // Выводит 100
  }
  ```  
    
  * ### Передача параметров по: значению, `&`, `const&`. Что выбрать и почему.  
  Аргументы в функцию можно передавать по значению, по ссылке, по константной ссылке. Если передавать по значению, то в функцию копируется переданный аргумент. Если по ссылке, то берётся ссылка на переданный агрумент (то есть если теперь его поменять внутри функции, то он поменяется и в том месте, где была вызвана функция). Передача аргумента по константной ссылке не даёт нам изменять его внутри функции.  
  Передача по ссылке нужна, если мы хотим как-то модифицировать переданный аргумент в функцию.  
  Передача по константной ссылке нужна, если мы не хотим менять наш объект внутри функции. При этом, копировать его лишний раз слишком дорого (например копировать матрицу 1000 на 1000 элементов, по которой мы хотим лишь разок пробежаться, не редактируя её, тупо, потратим на это кучу лишнего времени), поэтому лучше передать его по ссылке и запретить редактирование.  
  Отдельный разговор про верменные объекты. Если передать врементый объект в функцию как параметр, то либо по значению, либо по константной ссылке. По ссылке не получится (обычно не скомпилируется, но можно это как-то обойти и получить UB). При передаче временного объекта по константной ссылке, время его жизни продлевается.  
  ```C++
  size_t foo(const std::vector<int> &a){
      return a.size(); // 3
  }
  int main() {
      std::cout << foo({1, 2, 3});
  }
  ``` 
  Из-за этой фичи легальными являются и такие конструкции, где время жизни опять же продлевается.  
  ```C++
  int main() {
      const std::vector<int> &a = std::vector<int>{1, 2, 3};
      std::cout << a.size(); // 3
  }
  ``` 
  * ### Передача `{}` в параметры.  
  Компилятор умная штука. Можно передавать что-то в фигурных скобках, он по контексту догадается, чем это должно быть. Например тут он преобразует это в вектор интов. Это так называемое `List-initialization`. (см. соответствующий билет)
  ```C++
  void foo1(std::vector<int> arr){}
  int main() {
      foo1({1, 2, 3});
  }
  ```  
  * ### Неименованый параметр и `[[maybe_unused]]`  
  Неименованный параметр подробно описан выше. Вместо него можно использовать аргумент с каким-то фиктивным названием и пометить его `[[maybe_unused]]`  
  Приведу ещё один пример, где это используется: теги в аргументах функции. Мы заводим две фиктивные структуры с говорящими именами, делаем перегрузку функции. В одном месте передаём фиктивный параметр типа первой структуры, во второй функции фиктивный параметр второй структуры.  
  ```C++
  struct multi_five{};
  struct multi_ten{};
  int foo(int a, multi_five){
      return a * 5;
  }
  int foo(int a, multi_ten){
      return a * 10;
  }
  int main() {
      foo(1, multi_five{}); // 5
      foo(1, multi_ten{}); // 10
  }
  ```  
  
* ## Возвращаемое значение
  * ### Возврат по значению, ссылке, константной ссылке.  
  При возврате по значению, возвращаемый объект будет копироваться в переменную, куда вы его запишите.  
  При возврате по ссылке, функция возвращается ссылку на объект. Поэтому стоит быть аккуратным. В следующем примере пытаемся вернуть ссылку на локальную переменную, которая уберётся со стека после окончания выполнения функции, поэтому получаем UB.  
  ```C++
  int& foo1(int a){
      int b = a + 1;
      return b; // UB
  }
  int main() {
      int c = foo1(4);
      std:: cout << c;
  }
  ```  
  Применять возращение значения по ссылке можно например, если нам в параметрах передали какой-то аргумент по ссылке. То есть после окончания функции, он не будет уничтожен, поэтому позвращать на него ссылку совершенно легально.  
  ```C++
  int& foo1(int &a){
      a++;
      return a; // OK
  }
  int main() {
      int c = 5;
      int &b = foo1(c); // 6
      b++; // 7
      std::cout << c; // 7
  }
  ```
  Или например, можно возвращать ссылку на статический объект, объявленный внутри функции.
  ```C++
  int& foo1(){
      static int a = 100;
      a++;
      return a; // OK
  }
  int main() {
      int &c = foo1();
      std::cout << c << "\n"; // 101
      foo1();
      std::cout << c << "\n"; // 102
  }
  ```  
  Ну и можно возвращать константные ссылки. Всё работает интуитивно.  
  ```C++
  const int& foo1(int &a){
      a++;
      return a; // OK
  }
  int main() {
      int c = 5;
      const int &b = foo1(c); // 6
      b++; // Compilation error
  }
  ```
  * ### Возврат `{}`.  
  Возвращение из функции `{}` возможно только если возвращать что-то по значению (ну очевидно, не понятно что бы означало вернуть ссылку на пустые скобки. Это просто не скомпилится). В этом случае, вызововется Default initialization у элемента возвращаемого типа. То есть если функция от инта, то вернётся 0.  
   ```C++
  int foo1(){
      return {};
  }
  int main() {
      std::cout << foo1(); // 0
  }
  ```
  * ### `[[nodiscard]]`, возможные стратегии применения: когда не имеет смысла игнорировать возвращаемое значение, когда игнорировать опасно  
  Например, опасно игнорировать возвращаемый объект какой-то структуры. Если мы использовали внутри функции Dynamic storage duration, и возвращаем какой-то объект, в предположении что его после нужно пудет удалить. Если же мы его никуда не сохраним, произойдёт утечка памяти. Имеет смысл запрещать игнорировать возвращаемое значение, например если мы переопределяем какой-то арифметический оператор, как `+` в `bigint`. (Речь идёт о `C-style pointer`, с `unique_ptr` всё нормально будет, он почистится).  
  Так же если функция ничего не меняет вне себя, то ситуация, когда мы никуда не сохранили её значение означает, что мы попросту впустую потратили время на её выполнение, и это не дело.  
  Или если функция связана с обработкой ошибки, то идейно мы обязаны как-то исползользовать возвращаемое ей значение.  
* ## Перегрузка функций:
  * ### Что входит в сигнатуру, что не входит (например, значение по умолчанию).  
  Сигнатура функции включает имя функции, а также количество, порядок и тип ее формальных параметров.  
  Две перегруженные функции не должны иметь одинаковую сигнатуру.  
  Возвращаемое значение не является частью сигнатуры функции.  
  Две эти функции имеют одинаковую сигнатуру:  
  ```C++
  int Divide (int n, int m) ; 
  double Divide (int n, int m) ;
  ```
  * Типы-тэги для пояснений к перегрузкам (04-210923/01-functions/04-tags)
  Пояснил за тэги в пункте про безымянные и `[[maybe_unused]]`аргументы.  
  * ### Синтаксис `= delete` с C++11.  
  Если мы хотим запретить, например копирующий конструктор, можем воспользоваться конструкцией = delete: чтобы пометить их как удаленные функции.  
  ```C++
  unique_ptr(const unique_ptr&) = delete;
  unique_ptr& operator=(const unique_ptr&) = delete;
  ```
  Отличие удаления этих функций от их объявления как private.Удаленные функции не могут использоваться никоим образом, так что даже код функциичлена или функций, объявленных как friend, не будет компилироваться, если попытается.  
  Так же можно запрещать перегружать метод:  
  ```C++
  void foo(int x) {
      std::cout << "foo(" << x << ")\n";
  }

  void foo(double) = delete;  // Last step: if chosen by overload resolution, fail compilation.
  ```
  * ### Проблемы с разделением `nullptr`, `NULL`, `0`.  
  nullptr: это отдельный тип, а вот 0/NULL — это инты. Поэтому с перегрузками беда. Различие между NULL и 0 чаще всего практически никакого - (идеологически NULL показывает, что там пусто.  
  `#define NULL 0` //чаще все это именно так и есть  
  `nullptr` - значит что ни на что не указывает - необходимо использовать для указателей
  ```C++
  int *a=nullptr;
  *a; //UB!!!
  ```
  После 11 плюсов с взаимнозаменяемостью этих трёх штук полная лажа, так что `NULL` не стоит использовать вообще никогда.
  * ### Не было: `noexcept`.
  * ### Не было: правил выбора перегрузки точнее "выбирается перегрузка наиболее точная или ambiguous".
* ## Указатели на функции: синтаксис, использование.
  * ### Не было: конверсии между указателями, что происходит с перегрузками.

Тесно связано с: методы.
</details>

<details>
<summary>
 Жизнь объектов
</summary>


### Семантика копирования

В C++ по умолчанию при присваивании объекта / 
передаче объекта в функцию или возврате из функции ожидается, что объект будет скопирован и 
изменения, произошедшие с копией не мутируют сам объект.

При этом существует способ создать ссылку на объект, то есть добавить новое имя для ровно того же объекта в памяти.
Для этого импользуется синтаксис `Type &refer = ....;`, функции также могут принимать аргументы по ссылке. 
При возвращении ссылки из функции нужно быть очень осторожным - локальные переменные умирают при завершении функции, 
возникает dangling reference - ссылка на умерший объект. Обращение по ней - UB. [stackowerflow](https://stackoverflow.com/questions/46011510/what-is-a-dangling-reference)


```c++
void foo(std::vector<int> a) {
    a.push_back(1);
    std::cout << a.size(); 
} 

void bar(std::vector<int>& a) {
    a.push_back(1);
    std::cout << a.size();                                  
} 


int main() {
    std::vector<int> a{0};
    foo(a); // 2
    std::cout << a.size(); // 1 
    bar(a); // 2
    std::cout << a.size(); // 2  
    return 0;
}
```

Пример с dangling reference

```c++
#include <iostream>
#include <vector>

std::vector<int>& foo() {
    std::vector<int> vec{1, 2, 3};
    return vec;
}

int main() {
    std::vector<int> vec = foo();
    std::cout << vec.size() << "\n"; // UB
}
```

### Storage duration

Storage duration - характеристика объектов, опиисание их времени жизни - момента, когда они создаются и умирают.
[cppreference](https://en.cppreference.com/w/cpp/language/storage_duration) - полное описание.
Мы рассматриваем automatic, static и dynamic.

#### Automatic storage duration

Наиболее распространённая storage duration - мы создаём объект при проходе через объявление переменной - её значение 
(обычно оно кладётся на стэк, но стандарт это никак не оговаривает). Объект умирает, когда эта переменная 
становится невидимой навсегда (shadowing не считается, т.к. в какой-то момент переменные снова становятся видимыми).
У полей структуры с automatic storage duration - такой же storage duration. 

```c++
int main() {
    std::vector<int> v;                    // (1) - created

    for (int i = 0; i < 10; i++) {
        std::vector<int> v;                // (2) - created (10 times)
        if (i % 2 == 0) {
             break;                        // (2) - deleted
        }
    }                                      // (2) - deleted
    v.push_back(1);                      
    return 0;                              // (1) deleted
}


```

#### Static storage duration

Переменные инициализируются в какой-то момент и живут до окончания всей программы. Основной пример -
глобальные переменные. Можно создать и локальные объекты с таким же storage duration - для этого
их нужно пометить `static Type var;`. Они инциализируются только при первом прохождении через строчку с их
объявленем, а затем существуют до конца выполнения программы. При их инициализации доступны вске видимые объекты, 
существующие в этот момент (в частности - аргументы функции, в которой они созданы).

```c++
std::vector foo(1000, 0);                 // (1) - created before main

int count(int start) {
    static int current = start;           // (2) - Created on first call; 
    return current++;
}

int bad_counter(int b){
    static int a{};                       // (3) Value-initialzation on first call
    a = b;                                // assigment on every call
    return a++;                                
}

int main() {
    foo.push_back(0);
    std::cout << count(5) << std::endl;           // 5
    std::cout << count(5) << std::endl;           // 6
    std::cout << count(0) << std::endl;           // 7
    std::cout << count(101) << std::endl;         // 8
    std::cout << bad_counter(5) << std::endl;     // 5
    std::cout << bad_counter(5) << std::endl;     // 5
    std::cout << bad_counter(0) << std::endl;     // 0
    std::cout << bad_counter(101) << std::endl;   // 101
}

```

Обычно такие переменные помещаются в область глобальных переменных, поэтому на практике имеет смысл создавать
большие объекты именно таким способом, чтобы не тратить память на стэке.

Здесь можно встретить все проблемы, связанные с SIOF [билет 33](https://github.com/khbminus/CppTickets/blob/master/tickets/ticket33.md).
Про порядокс (или его отсутсвие инициализации таких переменных можно почитать [тут](https://en.cppreference.com/w/cpp/language/initialization#Non-local_variables))
и в билете про инициализацию


#### Dynamic storage duration

Программа сама полностью управляет временем жизни. При вызове оператора `new Type;` - создаётся
объект, значение этого выражения - указатель на него. Для того, чтобыы уничтожить объект используется
`delete ptr;`.

При попытке удалить объект 2 раза или удалить объект, созданый не при помощи опретаора `new` - 
возникает UB.
              
```c++

struct Foo {
    std::vector<int> vec(100);
}

int main() {
    Foo *ptr = new Foo;
    int bar;
    std::cout << ptr->vec.size() << std::cout;
    delete ptr; // To avoid memory leak
    //delete ptr; // Double free - UB; 
    //delete &bar; // UB;
}

```

Неосвобождённая память живёт до окончания программы - дальше современные ОС её освобождают. Такая ситуация называется утечкой памяти, 
она может вызвать отложенные проблемы.

Есть целый зоопарк new/delete; 

Можно выделять целые массивы при помощи `new Type[n]` - в таком случае освобождать память следует при помощи `delete[] ptr` - 
иначе UB (В том числе при попытке сделать `delete ptr;`). 

Для new работает много инициализаций:

* default - `new Type`
* default - `new Type()`
* default - `new Type{}`
* direct - `new Type(10)`
* direct list - `new Type{10}`

* Инициализация массивов - `new Foo[n]{val1, val2, val3}` - неинициализированные инициализируются по умолчанию.




### Время жизни временных объектов

Временные объекты умирают по завершении вычмсления выражения где они возникли, но при этом если создать
константную ссылку на временный объект, его время жизни продлится, чтобы соответсвовать времени жизни этой ссылки.

Важно, что эффект теряется, если мы инициализируем новую ссылку на временный объект старой.


```c++

const std::vector<int> &first = std::vectorP{0, 0, 0};
std::cout << first.size() << std::endl; // NO UB
 ....
// maybe another scope
const std::vector<int> &second = first; // would have been dangling if lifetime of second had been wider than lifetime of first;     
}
```

Это может иметь значение, если 


```c++
int const& func(int const& x) {
    return x;
} 


int main() {
    const int &first = func(1);
    std::cout << first; // UB
}
```
т.к. время жизни объекта продлевается только до времени жизни x. x - исчезает после завершения вычисления функции.

Подобное можно встретить и в STL - функция std::min - принимает и возвращает ссылки

```c++
int main() {
    const auto &val = std::min(0, 1); // Dangling reference
}
```
[ну или проблемы range-based for связанная с тем, что его рассахаривание - несколько выражений](https://github.com/Nekrolm/ubbook/blob/master/lifetime/for_loop.md) 
</details>

<details>
<summary>
</summary>


## Содержание

Каждый указатель относится к одному из 4 видов:
1. Указатель на объект или функцию.
2. Указатель на память следующую за последним элементом объекта.
3. Нулевой указатель - `nullptr`.
4. Invalid указатель - указывает куда угодно (мы не знаем, что в той памяти лежит).

* ## Базовый синтаксис
  * ### Объявление
    В общем случае выгладит так: `T *P`, где `T` - 
    это тип того, на что указатель указывает, `P` - это имя указателя.
    
    Примеры объявления (и инициализации в одном месте, а на самом месте в двух):
    ```c++
    const int ci = 10;       // просто cosnt int (не указатель)
    const int *pc = &ci;     // pс - указатель на переменную ci
    int i;                   // i - просто int (не указатель)
    int *p;                  // p - указатель (не инициализировали)
    
    struct node {
        int value;
        node *next, *prev;   // со структурками/классами синтаксис ровно такой же синтаксис
    };
    
    int main() {
    }
    ```
    
    >_Замечание:_ звездочка пишется именно перед указателем 
    (то есть для каждого указателя нужна отдельная звездочка)
    `node *next, *prev;`
    
    Приколы ([zero initialization](https://en.cppreference.com/w/cpp/language/zero_initialization)):
    ```c++
    int *ptr; // по-умолчанию ставится в nullptr (zero initialization)
              // кратко: nullptr ставится всем неинициализированным указателям со static storage duration
    
    int main() {
        int *another_ptr; // указывает на рандомное место в памяти (Invalid указатель)
    }
    ```

  * ### Разыменование
    
    Чтобы получить объект, на который ссылается указатель `ptr`, надо написать `*ptr`.

    >При разыменовании указателей вида 2,3,4 получаем UB.      

    Собственно, пример:
    ```c++
    #include <iostream>
      
    int *p;        			// просто указатель (nullptr по умолчанию)
    int x = 10;      		// просто int
    int *xp = &x; 			// xp с этого момента - указатель на x
      
    int main() {
      int y = *xp;          // в y копируем значение x
      int *nxp = xp;    	// nxp теперь тоже указатель на x
      
      std::cout << (*nxp) << " " << x << "\n";  // 10 10
      if (*nxp == x) {
          std::cout << "true\n";                // prints true
      }
    
      // int z = *p;      	// UB при разыминовании nullptr
      // int *p;         	// указатель p (invalid указатель)
      // *p;             	// тоже UB, потому что указатель - invalid
    }    
    ```
    >_Замечание:_ При выводе скобочки потерять нельзя из-за [приоритетов операторов](https://en.cppreference.com/w/cpp/language/operator_precedence).
  * ### Взятие адреса
        
    Собственно, чтобы получить адрес, на который указывает указатель `ptr`, 
    нужно написать `ptr` (то есть адрес, куда указывает указатель - это просто его значение).
  
    Пример:
    ```c++
    #include <iostream>
    
    int x = 10;        // просто int 
    int *px1 = &x;     // указатель на x
    int *px2 = &x;     // еще указатель на x
   
    int main() {
      std::cout << px1 << " " << px2 << "\n";    // выводим адреса переменной,
                                                 // на которую указывают px1 и px2
                                                 // (они совпадут)
      
      std::cout << &px1 << " " << &px2 << "\n";   // выводим адреса самих указателей
                                                  // (они разные) 
    }
    ```
    >_Замечание 1:_ `&ptr` - память, где лежит указатель. 
    `ptr` - память, где лежит переменная, на которую указывает указатель.   

  * ### Стрелочка `->`
    
    `->` - это просто синтаксический сахар для того, чтобы работать со структурками/классами
    было удобней.
  
    Написать стрелочку - то же самое, что и разыменовать указатель и применить к результату `operator.`.
    
    Пример:
    ```c++
    #include<iostream>
    
    struct node {            // структурка для двусвязного списка
      int data;              // значение node  
      node *next, *prev;     // указатели на предыдущий и следующий элементы списка
    }
    
    int main() {
      node a{10}, b{20}, c{30};  // создаем три элемента (пока что раздельных)
      a.prev = nullptr;          // говорим, что a - это начало списка, проинициализировав 
                                 // его предыдущий элемент nullptr (такой у нас инвариант)
      
      a.next = &b;               // связали элементы в список
      b.next = &c;               
      
      // теперь хотим вывести значение следующего элемента после a
      // давайте сделаем, как умеем
    
      std::cout << (*a.next).data << "\n";        // фуу
      
      // чтобы писать было на два символа короче, директор c++ придумал стрелочку:
    
      std::cout << a->data << "\n";               // теперь красиво 
    }              
    ```
  
* ## Реализация двусвязного списка
  Ну вот она:
  ```c++
  #include <iostream>
  
  struct node {
      int data;
      node *prev = nullptr, *next = nullptr;
  };
  
  void add_after(node& a, node&  b) {          // добавление элемента между a и a->next
      b.next = a.next;                         // говорим, что следующий за b элемент - это следующий за a в прошлом элемент
      if (b.next != nullptr) {                 // разыменование nullptr - UB
          b.next->prev = &b;                   // обновляем указатель на элемент идущий перед следующим за b
      }                                                                               
      a.next = &b;                             // все понятно: следующий за a теперь b
      b.prev = &a;                             // тоже понятно: предыдущий от b - это a
  }
  
  void add_before(node& a, node& b) {          // добавление элемента b между a->prev и a
      b.prev = a.prev;                         // элемент перед b теперь - это элемент перед a в прошлом
      if (b.prev != nullptr) {                 // разыменование nullptr - UB
          b.prev->next = &b;                   // обновляем указатель на идущий после элемента перед b
      }
      b.next = &a;                             // все понятно: следующий за b - теперь a
      a.prev = &b;                             // тоже понятно: следующий за a - теперь b
  }
  
  void remove(node& a) {                       // удаление элемента a 
      if (a.prev != nullptr) {                 // если есть элемент перед a, то обновим его
          a.prev->next = a.next;               // обновляем указатель на следующего за предыдущим элементом
      }
      if (a.next != nullptr) {                 // если есть элемент после a, то обновим его
          a.next->prev = a.prev;               // обновляем указатель на идущего пред слудющим за a
      }		
  }
  
  void print_list(node& head) {                // печть списка: не интеллектуально
      node *cur = &head;
      while (cur != nullptr) {                 // собственно, пока текущий выводмимый - не конец списка
          std::cout << cur->data << " ";       // выводим значение предыдущего head
          cur = cur->next;                     // теперь head - это следующий за head элемент
      }
      std::cout << "\n";                       // вывод пустой строчки, потому что почему бы и нет
  }
  
  int main() {
      node a{10}, b{20}, c{30}, d{40}, e{15};  // создание элементов и их связывание спомощью add-функций
      add_after(a, b);
      add_after(b, c);
      add_before(b, e);
      add_after(c, d);      
  
      print_list(a);  // 10 15 20 30 40
      print_list(b);  // 20 30 40
      print_list(c);  // 30 40
  
      remove(e);
  
      print_list(a);  // 10 20 30 40
  }
  ```
  >_Замечание:_ в конструкции типа `a.next->prev` мы сначала пишем точку, потому что `a` 
    был у нас не указателем, но, `a.next` - это указатель, поэтому, чтобы обратится к 
    его полям надо использовать стрелочку.
* ## Нулевой указатель
  Иногда хочется пометить, что указатель никуда не указывает. Это можно сделать с 
  помощью присвоения `nullptr` указателю. Такой указатель называется нулевым.
  > Разыменование нулевого указателя - это UB.
  
  Пример: 
  ```c++
  int main() {
    int *ptr = nullptr;
    if (ptr) {             // если ptr - это nullptr, то при конвертации к bool
                           // получим false. Иначе - true.
      // do something                  
    }
    if (ptr != nullptr) {  // так тоже делать никто не запрещает
      // do something
    }
    *ptr;                  // разыменование nullptr - UB
  }
  ```
  >_Замечание:_ Единственный случай, когда указатель при конвертации к `bool`
    вернет `false` - это случай, когда указатель нулевой.  
  
  До `C++11` стандартным нулевым указателем был макрос `NULL`, который определен нулем. 
  Ее лучше не использовать из-за вот таких приколов:
  ```c++
  #include <cstddef>
  #include <iostream>
   
  void foo(int*) {
    std::cout << "foo(int*);\n";
  }
   
  void foo(long) {
    std::cout << "foo(long);\n";
  }
   
  int main() {
    foo(nullptr);        // calls foo(int*)
    foo(NULL);           // compilation error (call is ambigous)
    foo(0);              // compilation error (call is ambigous)  
  }
  ```
  >_Замечание1:_ `NULL` и `0` могут быть сконвертированы и в `int`, и в указатель,
    а `nullptr` - это чисто про указатели.
  
  >_Замечание2:_ На cppreference [написано](https://en.cppreference.com/book/pointers#:~:text=Special%20null%20pointer),
    что `foo(NULL)` будет вызывать `foo(long)`, но у меня под всеми компиляторами и всеми разумными стандартами была ошибка компиляции.
  
  > _Замечаание3 (от ХБ):_ лично у меня при компиляции руками `g++ -std=c++17/03/11` g++ выкидывал предупреждение, что `NULL` кастуется к лонгу, при этом `clang++` вообще ничего не выкидывал. 
  
  Тем не менее, когда вы пишете `foo(NULL)`, вы ожидаете, что вызовется перегрузка `foo(int*)`, чего не происходит.
* ## Отличие ссылок от указателей
  * ### Изменяемость
    
    >Ссылка после создания всегда указывает на один элемент, в то время как указатель 
    можно перепривязывать.
    
    Пример:
    ```c++
    #include <iostream>
    
    int main() {
      int x = 10;
      int y = 20;
      int *ptr = &x;                             // указатель на x
      int &x_ref = x;                            // ссылка на x 
      std::cout << ptr << " " << &x_ref << "\n"; // указывают на одну и ту же память
      ptr = &y;                                  // перепривязали указатель к y
      x_ref = y;                                 // это уже присвоение y в x_ref, т.е. в x
      std::cout << ptr << " " << &x_ref << "\n"; // у ptr адрес поменялся на адрес y, а у x_ref остался тем же
    }
    ```
  * ### Обнуляемость
    
    >Указатели имеют нулевое состояние `nullptr`, в то время как ссылки таким не обладают. 
    Т.е. ссылка всегда должна указывать на объект, а указатель - нет.
    
    Пример:
    ```c++
    #include <iostream>
    
    int *g_ptr;                 // просто указатель (по умолчанию nullptr)
    
    int main() {
      int *ptr = nullptr;       // просто нулевой указатель
      int &ref;                 // compilation error: ref объявлена, как ссылка, но не инициализирована  
    }
    ```
  * ### Хранение в контейнерах
    Указатели спокойно кладутся в контейнеры, а вот ссылки туда класть нельзя. 
    (можно, если использовать `std::reference_wrapper`, который превращает ссылку в 
     копируемый и присваиваемый объект, но это не просто ссылки)
    
    >Ссылки нельзя копировать и присваивать. (Вообще ссылка - это не объект, 
     а в контейнерах должны объекты лежать)
  
    Пример:
    ```c++
    #include <vector>
    
    int main() {
      std::vector<int*> v_ptr(10);       // создается вектор из 10 нулевых указателей
      std::vector<int&> v_ref(10);       // compilation error: с длинной ошибкой
    }
    ```
    
    Пример с `std::reference_wrapper`:
    
* ## Арифметика указателей
  * ### `array-to-pointer decay`
    Ссылка на массив - это ссылка на его первый элемент. Значит можно сделать вот так:
    
    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
  
    int main() {
      int data[]{10, 20, 30, 40};
      
      int *p1 = &data[0];        // берем адрес первого элемента
      assert(*p1 == 10);
  
      int *p2 = data;            // array-to-pointer decay. Только массивы, не вектора.
      assert(p2 == p1);
      assert(*p2 == 10);
      *p2 = 12;                  // можно менять
      assert(*p2 == 12);
      assert(data[0] == 12);
      *p2 = 10;
    }
    ```
    >_Замечание:_ Только для C-шных массивов (не для векторов).
    
  * ### Операции `+`, `++`, `-`, `--` указателей с `int`
    Указатели в массиве можно смещать (главное, надо остаться либо в массиве,
    в котором мы находились, либо в следующей ячейке после конца массива). Отдельные объекты
    трактуются, как массивы из одного элемента, то есть можно получать указатель следующий за последним.
    
    `+`, `++` - смещение вперед.
    
    `-`, `--` - смещение назад.
  
    >Работает ровно как у итераторов.
    
    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
  
    int main() {
      int data[]{10, 20, 30, 40};
      
      int *p1 = &data[0];               // взяли указатель на первый элемент
      int *p2 = data;                   // array-to-pointer decay
  
      // Арифметика такая же, как и у итераторов.
    
      int *q = p1 + 2;                  // указатель на data[2]
      assert(q == &data[2]);
      assert(data + 2 == &data[2]);
      assert(*q == 30);
  
      int *r = q;                       // указатель на q, то есть на data[2]
      r--;                              // теперь это указатель на data[1]
      assert(r == &data[1]);
      assert(*r == 20);
  
      int x = *r--;                   
      
      // Эквивалентно вот этой штуке:
      // int *old_r = r;
      // r--;
      // int x = *old_r;
      
      assert(x == 20);
      assert(data[1] == 20);
      assert(data[0] == 10);
      assert(r == &data[0]);
      assert(*r == 10);
  
      // То же самое, только с префиксным оператором
    
      r = &data[1];
      int y = *--r;
      assert(y == data[0]);
      assert(y == 10);
      assert(r == &data[0]);
  
      std::ptrdiff_t diff = r - q;      // std::ptrdiff_t - тип, в который влазит вся память на компе
      assert(diff == -2);
      assert(&data[0] - &data[2] == -2);
  
      assert(data[1] == *(data + 1));  // По определению, синтаксический сахар для массивов (not vectors).
      assert(data[1] == *(1 + data));
      assert(1[data] == *(1 + data));
      int *data_ptr = data;
      assert(data_ptr[1] == *(data_ptr + 1));
      assert(data_ptr[1] == data[1]);
    }
    ```
    >_Замечание:_ `data[1]` - это на самом деле `*(data + 1)`.
  * ### `one-past-the-last`
    > Указатель на память, следующую за последним элементом массива - корректный, но его нельзя разыменовывать.
    
    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
    #include <iostream>
  
    struct Foo {
      int x = 0;
      int y = 1;
    };
    
    int main() {
      int data[]{40, 20, 10, 30};
  
      int *one_past_end = data + 4;
      assert(one_past_end - data == 4);
      // int var = *one_past_end;                     // разыменование - UB.
        
      Foo a;
      int *val = &a.x;
      val++;                                          // корректно (ope-past-the-last)
      // *val;                                        // разыменование - UB
    }
    ```
  * ### Сравнение указателей
    >`=`,`!=` - можно сравнивать любый указатели. Возвращает, равен ли один другому.
    
    > `>`,`>=`,`<`,`<=` - можно сравнивать указатели из одного массива или из одной структурки. 
      В случае сравнения разных объектов - `unspecified behaviour`.
    
    > `-`: Вычитать два указателя можно только из одного массива
  
    >В контейнерах используется `std::less`, который на всех указателях строит _какой-то_ полный порядок,
      поэтому можно пихать указатели, например, в `std::set`.
    
    Пример:
    ```c++
    #include <cassert>
    #include <functional>
    #include <iostream>
    #include <set>
  
    struct Foo {
      int a = 10;
      int b = 20;
      int c = 30;
    };
  
    int main() {
      {
          int data[4];
          int end;
          std::cout << (&end - data) << "\n";  // UB
          std::cout << (data < &end) << "\n";  // unspecified, может быть неконсистентным!
          std::cout << (data < &end) << "\n";  // unspecified, может быть неконсистентным!
          assert(data != &end);  // ok
      }
      {
        Foo f;
        std::cout << &f.b - &f.a << "\n";  // UB: не массив
        assert(&f.a < &f.b);  // ok: члены с одним уровнем доступа (private/protected/public) упорядочены
        assert(&f.a != &f.b);  // ok: разные int
      }
      {
        std::set<int*> s;
        int a = 10, b = 20;
        s.insert(&a);  // ok
        s.insert(&b);  // ok
  
        std::less<int*> comparator;
        std::cout << comparator(&a, &b) << "\n";  // implementation-defined
      }
    }
    ```

* ## C-style-strings/ASCIIZ-строки/строки в стиле Си
  * ### Определение
    `C-style-strings` - это не тип, а конвенция. 
     > "Если у нас есть массив, где сначала идут символы, символы, символы, а потом символ `\0`,
        то это сишная строка", — Егор Суворов.
  * ### Сохранение строкового литерала в `char *`
    С помощью `array-to-pointer decay` можно сконвертировать массив (сишную строку) в указатель.
    
    Пример:
    ```c++
    int main() {
      char str[] = "hello";                              // сишная строка
      // char str[] = {'h', 'e', 'l', 'l', 'o', 0};      // то же самое
      
      char str_ptr = *str;                               // array-to-pointer decay
    }
    ```
  * ### Сравнение и получение длины
      
    >_Опасно:_ если есть две си-шные строки `s` и `t`, то если написать `a < b`, то будут сравниваться указатели, 
      что приведет к `unspecified behaviour`. 
      
    >_Опасно:_ казалось бы на равенство указатели сравниваются без `unspecified behaviour`,
      почему бы тогда не сравнить `s == t`. Нельзя так как не гарантируется, что у 
      одинаковых строковых литералов один и тот же адрес. Ну и вообще разные строковые
      литералы могут обозначать одну и ту же сишную строку (например `"hello"` и `"hello\0"`). 
      То есть придется тоже цикликом.
      
    Но если написать `*a < *b`, то сравнятся лишь первые символы, а значит придется писать цикл `:(`.
      
    Сравнение на меньше (остальные аналогично):
    ```c++
    bool is_less(char* a, char* b) {
      for (int i = 0; a[i] || b[i]; i++) {           // (a[i] || b[i]) - нулевой символ кастуется к false, остальные - к true
        if (a[i] != b[i]) {
          return a[i] < b[i];
        }
      }
      return false;
    }
    ```
      
    Получить длину сишной строки можно так:
    ```c++
    int get_length(char* s) {
      int res = 0;
      while (s[res] != '\0') {    // идем до последнего символа, ответ - сколько элементов прошли
        res++;
      }
      return res;
    }
    ```
      
    >_Опасно:_ длина сишной строки считается за линию. Даже `std::strlen()`.
      
  * ### Выделение памяти, аллокация, конкатенация {#oper}
      
    Мы хотим сконкатенировать две сишные строки. Беда в том, что сишные строки - 
    это не отдельные объекты, это указатели.
      
    То есть если мы хотим сконкатенировать две строки и получить новую, то нам надо 
    где-то выделить под нее память.
      
    Функция для конкатенации: 
    ```c++
    char* strcat(cosnt char* a, const char* b) {
      char* res = new char[std::strlen(a) + std::strlen(b) + 1]; // +1 для '\0'.
      int res_len = 0;
      for (int i = 0; a[i]; i++) {
        res[res_len++] = a[i];
      }
      for (int i = 0; b[i]; i++) {
        res[res_len++] = b[i];
      }
      res[res_len] = '\0';
      return res;
    }
    ```
      
    >_Опасно:_ теперь про каждую сишную строчку мы обязаны помнить, как мы ее получили.
      В зависимости от способа получение вызывать нужный `delete`.
      
    Пример (реализацию `strcat` возьмем из прошлого примера):
    ```c++
    #include <cstring>
    #include <iostream>
    #inlude "прошлый_пример.h"
      
    int main() {
      char* x = "xyz";
      char* y = strcat("xy", "z") + 1;
      
      // миллион строк кода
      
      delete[] (y - 1); // тут надо не забыть, что мы выделили именно массив и y взят со съездом на 1
      
      // еще надо не забыть, что вызывать delete от x не надо, потому что
      // у x automatic storage duration
    }
    ```
    
  * ### Небезопасность функции чтения

    Рассмотрим реализацию `readWord` из известного среди всей прогрессивной общественности 
    файлика `optimization.h`.
  
    Напоминание реализации readWord:
    ```c++
    void readWord(char *s) {
      int c = readChar();         // readChar просто смотрит на текущий символ из буфера
      while (c > 32)
        *s++ = c, c = getChar();  // c++ выпендреж от Cерёжи. Просто считали очередной символ.
      return с != -1;             // видимо, возвращает, считалось ли что-то?
    }
    ```
    
    >_Опасно:_ что произойдет, если мы считаем больше символов, чем выделено в `s`? 
      UB конечно же.
  
  * ### Кто владеет результатом `c_str`
    
    Что вообще такое `c_str`? Это метод у `std::string`, который возвращает сишную строчки.
    
    >_Собственно ответ:_ результатом `c_str` владеет `std::string`, который его вызвал.
    
    Пример:
    ```c++
    #include <iostream>
    #include <string>
    
    int main() {
      const char *s_ptr;
      {
        std::string s = "hello";
        s_ptr = s.c_str();
        std::cout << s_ptr << " (1)\n";    // корректно вывели сишную строчку
      }                                    // конец зоны видимости s (тут она умирает)
      std::cout << s_ptr << " (2)\n";      // UB: строчка, владеющая той памятью уже не существует
    }
    ```</details>

