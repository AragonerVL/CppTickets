<details>
<summary>
 Template Ticket
</summary>


**жирный текст** _курсив_ ~~ошибка~~ ==мнения?== `inline code block` [ссылка на фулл](https://www.markdownguide.org/cheat-sheet/)
```c++
int main() {
    return 0;
}
```

### Подзаголовок

LMAO
Not bottom text, lol
</details>

<details>
<summary>
 4. Функции
</summary>

* ## Параметры
  * ### Синтаксис (пропущенное имя, значение по умолчанию в объявлении/определении)  
  У функции есть объявление и определение, хотя обычно они пишутся сразу вместе. У функции есть тип, название, в круглых скобках передаются параметры, в фигурных само тело функции.  
  ```C++
  void foo(int a, int b){}
  void foo(vector v = {1, 2, 3}){} // параметр по умолчанию
  ```
  Вот так будет выглядеть, если хотим разделить объявление и определение.  
  ```C++
  void foo(int a, int b);
  void foo(int a, int b){
     return a + b;
  }
  ```
  Это может быть полезно, например когда мы хотим использовать две функции друг в друге. При этом одна из них будет определена всегда равньше другой, поэтому приходится придегать к `Forward decloration`. То есть мы говорим, что такая функция есть, и мы можем её вызывать, но вот её определение мы попозже напишем.
  ```C++
  int bar(int x);
  int foo(int y){
      return bar(y - 1) + 1; // OK
  }
  int bar(int x){
      if(x <= 0) return 1;
      return foo(x - 1);
  }
  ```
  Ещё один случай, когда у нас есть несколько единиц трансяции. В этом случае там так же иногда приходится использовать функцию в единице трансляции отличной от той, где мы собственно эту функцию определяем. Поэтому приходится в каждой отдельной единице трасляции писать объявление, если мы хотим использовать функию.  
  Можно в качестве параметра использовать агрумент без имени, указав только его тип. Это, например, используется, чтобы различять префиксный и постфиксный декриметны и инкременты. Обратиться к переданному таким образом аргументу внутри функции не получится. При этом распалагать их можно в перемешку с обычными аргументами, но до агрументов со значениями по умолчанию.  
  ```C++
  void foo1(int a, int, int b, int, int, int c = 100){} // OK
  void foo2(int a, int, int b, int, int, int c = 100, int){} // Compilation error
  void foo3(int a, int, int b, int, int, int c = 100, int = 1){} // OK
  ```
  Аргументы со значениями по умолчанию всегда идут после всех остальных. Можно передавать им новые значения при вызове функции. Задать значение по умолчанию можно как в объявлении, так и в определении функции, но только либо там, либо там.
  ```C++
  void foo1(int c = 100);
  void foo1(int c){
    std::cout << c; // Выводит 100
  }
  ```  
    
  * ### Передача параметров по: значению, `&`, `const&`. Что выбрать и почему.  
  Аргументы в функцию можно передавать по значению, по ссылке, по константной ссылке. Если передавать по значению, то в функцию копируется переданный аргумент. Если по ссылке, то берётся ссылка на переданный агрумент (то есть если теперь его поменять внутри функции, то он поменяется и в том месте, где была вызвана функция). Передача аргумента по константной ссылке не даёт нам изменять его внутри функции.  
  Передача по ссылке нужна, если мы хотим как-то модифицировать переданный аргумент в функцию.  
  Передача по константной ссылке нужна, если мы не хотим менять наш объект внутри функции. При этом, копировать его лишний раз слишком дорого (например копировать матрицу 1000 на 1000 элементов, по которой мы хотим лишь разок пробежаться, не редактируя её, тупо, потратим на это кучу лишнего времени), поэтому лучше передать его по ссылке и запретить редактирование.  
  Отдельный разговор про верменные объекты. Если передать врементый объект в функцию как параметр, то либо по значению, либо по константной ссылке. По ссылке не получится (обычно не скомпилируется, но можно это как-то обойти и получить UB). При передаче временного объекта по константной ссылке, время его жизни продлевается.  
  ```C++
  size_t foo(const std::vector<int> &a){
      return a.size(); // 3
  }
  int main() {
      std::cout << foo({1, 2, 3});
  }
  ``` 
  Из-за этой фичи легальными являются и такие конструкции, где время жизни опять же продлевается.  
  ```C++
  int main() {
      const std::vector<int> &a = std::vector<int>{1, 2, 3};
      std::cout << a.size(); // 3
  }
  ``` 
  * ### Передача `{}` в параметры.  
  Компилятор умная штука. Можно передавать что-то в фигурных скобках, он по контексту догадается, чем это должно быть. Например тут он преобразует это в вектор интов. Это так называемое `List-initialization`. (см. соответствующий билет)
  ```C++
  void foo1(std::vector<int> arr){}
  int main() {
      foo1({1, 2, 3});
  }
  ```  
  * ### Неименованый параметр и `[[maybe_unused]]`  
  Неименованный параметр подробно описан выше. Вместо него можно использовать аргумент с каким-то фиктивным названием и пометить его `[[maybe_unused]]`  
  Приведу ещё один пример, где это используется: теги в аргументах функции. Мы заводим две фиктивные структуры с говорящими именами, делаем перегрузку функции. В одном месте передаём фиктивный параметр типа первой структуры, во второй функции фиктивный параметр второй структуры.  
  ```C++
  struct multi_five{};
  struct multi_ten{};
  int foo(int a, multi_five){
      return a * 5;
  }
  int foo(int a, multi_ten){
      return a * 10;
  }
  int main() {
      foo(1, multi_five{}); // 5
      foo(1, multi_ten{}); // 10
  }
  ```  
  
* ## Возвращаемое значение
  * ### Возврат по значению, ссылке, константной ссылке.  
  При возврате по значению, возвращаемый объект будет копироваться в переменную, куда вы его запишите.  
  При возврате по ссылке, функция возвращается ссылку на объект. Поэтому стоит быть аккуратным. В следующем примере пытаемся вернуть ссылку на локальную переменную, которая уберётся со стека после окончания выполнения функции, поэтому получаем UB.  
  ```C++
  int& foo1(int a){
      int b = a + 1;
      return b; // UB
  }
  int main() {
      int c = foo1(4);
      std:: cout << c;
  }
  ```  
  Применять возращение значения по ссылке можно например, если нам в параметрах передали какой-то аргумент по ссылке. То есть после окончания функции, он не будет уничтожен, поэтому позвращать на него ссылку совершенно легально.  
  ```C++
  int& foo1(int &a){
      a++;
      return a; // OK
  }
  int main() {
      int c = 5;
      int &b = foo1(c); // 6
      b++; // 7
      std::cout << c; // 7
  }
  ```
  Или например, можно возвращать ссылку на статический объект, объявленный внутри функции.
  ```C++
  int& foo1(){
      static int a = 100;
      a++;
      return a; // OK
  }
  int main() {
      int &c = foo1();
      std::cout << c << "\n"; // 101
      foo1();
      std::cout << c << "\n"; // 102
  }
  ```  
  Ну и можно возвращать константные ссылки. Всё работает интуитивно.  
  ```C++
  const int& foo1(int &a){
      a++;
      return a; // OK
  }
  int main() {
      int c = 5;
      const int &b = foo1(c); // 6
      b++; // Compilation error
  }
  ```
  * ### Возврат `{}`.  
  Возвращение из функции `{}` возможно только если возвращать что-то по значению (ну очевидно, не понятно что бы означало вернуть ссылку на пустые скобки. Это просто не скомпилится). В этом случае, вызововется Default initialization у элемента возвращаемого типа. То есть если функция от инта, то вернётся 0.  
   ```C++
  int foo1(){
      return {};
  }
  int main() {
      std::cout << foo1(); // 0
  }
  ```
  * ### `[[nodiscard]]`, возможные стратегии применения: когда не имеет смысла игнорировать возвращаемое значение, когда игнорировать опасно  
  Например, опасно игнорировать возвращаемый объект какой-то структуры. Если мы использовали внутри функции Dynamic storage duration, и возвращаем какой-то объект, в предположении что его после нужно пудет удалить. Если же мы его никуда не сохраним, произойдёт утечка памяти. Имеет смысл запрещать игнорировать возвращаемое значение, например если мы переопределяем какой-то арифметический оператор, как `+` в `bigint`. (Речь идёт о `C-style pointer`, с `unique_ptr` всё нормально будет, он почистится).  
  Так же если функция ничего не меняет вне себя, то ситуация, когда мы никуда не сохранили её значение означает, что мы попросту впустую потратили время на её выполнение, и это не дело.  
  Или если функция связана с обработкой ошибки, то идейно мы обязаны как-то исползользовать возвращаемое ей значение.  
* ## Перегрузка функций:
  * ### Что входит в сигнатуру, что не входит (например, значение по умолчанию).  
  Сигнатура функции включает имя функции, а также количество, порядок и тип ее формальных параметров.  
  Две перегруженные функции не должны иметь одинаковую сигнатуру.  
  Возвращаемое значение не является частью сигнатуры функции.  
  Две эти функции имеют одинаковую сигнатуру:  
  ```C++
  int Divide (int n, int m) ; 
  double Divide (int n, int m) ;
  ```
  * Типы-тэги для пояснений к перегрузкам (04-210923/01-functions/04-tags)
  Пояснил за тэги в пункте про безымянные и `[[maybe_unused]]`аргументы.  
  * ### Синтаксис `= delete` с C++11.  
  Если мы хотим запретить, например копирующий конструктор, можем воспользоваться конструкцией = delete: чтобы пометить их как удаленные функции.  
  ```C++
  unique_ptr(const unique_ptr&) = delete;
  unique_ptr& operator=(const unique_ptr&) = delete;
  ```
  Отличие удаления этих функций от их объявления как private.Удаленные функции не могут использоваться никоим образом, так что даже код функциичлена или функций, объявленных как friend, не будет компилироваться, если попытается.  
  Так же можно запрещать перегружать метод:  
  ```C++
  void foo(int x) {
      std::cout << "foo(" << x << ")\n";
  }

  void foo(double) = delete;  // Last step: if chosen by overload resolution, fail compilation.
  ```
  * ### Проблемы с разделением `nullptr`, `NULL`, `0`.  
  nullptr: это отдельный тип, а вот 0/NULL — это инты. Поэтому с перегрузками беда. Различие между NULL и 0 чаще всего практически никакого - (идеологически NULL показывает, что там пусто.  
  `#define NULL 0` //чаще все это именно так и есть  
  `nullptr` - значит что ни на что не указывает - необходимо использовать для указателей
  ```C++
  int *a=nullptr;
  *a; //UB!!!
  ```
  После 11 плюсов с взаимнозаменяемостью этих трёх штук полная лажа, так что `NULL` не стоит использовать вообще никогда.
  * ### Не было: `noexcept`.
  * ### Не было: правил выбора перегрузки точнее "выбирается перегрузка наиболее точная или ambiguous".
* ## Указатели на функции: синтаксис, использование.
  * ### Не было: конверсии между указателями, что происходит с перегрузками.

Тесно связано с: методы.
</details>

<details>
<summary>
 Жизнь объектов
</summary>


### Семантика копирования

В C++ по умолчанию при присваивании объекта / 
передаче объекта в функцию или возврате из функции ожидается, что объект будет скопирован и 
изменения, произошедшие с копией не мутируют сам объект.

При этом существует способ создать ссылку на объект, то есть добавить новое имя для ровно того же объекта в памяти.
Для этого импользуется синтаксис `Type &refer = ....;`, функции также могут принимать аргументы по ссылке. 
При возвращении ссылки из функции нужно быть очень осторожным - локальные переменные умирают при завершении функции, 
возникает dangling reference - ссылка на умерший объект. Обращение по ней - UB. [stackowerflow](https://stackoverflow.com/questions/46011510/what-is-a-dangling-reference)


```c++
void foo(std::vector<int> a) {
    a.push_back(1);
    std::cout << a.size(); 
} 

void bar(std::vector<int>& a) {
    a.push_back(1);
    std::cout << a.size();                                  
} 


int main() {
    std::vector<int> a{0};
    foo(a); // 2
    std::cout << a.size(); // 1 
    bar(a); // 2
    std::cout << a.size(); // 2  
    return 0;
}
```

Пример с dangling reference

```c++
#include <iostream>
#include <vector>

std::vector<int>& foo() {
    std::vector<int> vec{1, 2, 3};
    return vec;
}

int main() {
    std::vector<int> vec = foo();
    std::cout << vec.size() << "\n"; // UB
}
```

### Storage duration

Storage duration - характеристика объектов, опиисание их времени жизни - момента, когда они создаются и умирают.
[cppreference](https://en.cppreference.com/w/cpp/language/storage_duration) - полное описание.
Мы рассматриваем automatic, static и dynamic.

#### Automatic storage duration

Наиболее распространённая storage duration - мы создаём объект при проходе через объявление переменной - её значение 
(обычно оно кладётся на стэк, но стандарт это никак не оговаривает). Объект умирает, когда эта переменная 
становится невидимой навсегда (shadowing не считается, т.к. в какой-то момент переменные снова становятся видимыми).
У полей структуры с automatic storage duration - такой же storage duration. 

```c++
int main() {
    std::vector<int> v;                    // (1) - created

    for (int i = 0; i < 10; i++) {
        std::vector<int> v;                // (2) - created (10 times)
        if (i % 2 == 0) {
             break;                        // (2) - deleted
        }
    }                                      // (2) - deleted
    v.push_back(1);                      
    return 0;                              // (1) deleted
}


```

#### Static storage duration

Переменные инициализируются в какой-то момент и живут до окончания всей программы. Основной пример -
глобальные переменные. Можно создать и локальные объекты с таким же storage duration - для этого
их нужно пометить `static Type var;`. Они инциализируются только при первом прохождении через строчку с их
объявленем, а затем существуют до конца выполнения программы. При их инициализации доступны вске видимые объекты, 
существующие в этот момент (в частности - аргументы функции, в которой они созданы).

```c++
std::vector foo(1000, 0);                 // (1) - created before main

int count(int start) {
    static int current = start;           // (2) - Created on first call; 
    return current++;
}

int bad_counter(int b){
    static int a{};                       // (3) Value-initialzation on first call
    a = b;                                // assigment on every call
    return a++;                                
}

int main() {
    foo.push_back(0);
    std::cout << count(5) << std::endl;           // 5
    std::cout << count(5) << std::endl;           // 6
    std::cout << count(0) << std::endl;           // 7
    std::cout << count(101) << std::endl;         // 8
    std::cout << bad_counter(5) << std::endl;     // 5
    std::cout << bad_counter(5) << std::endl;     // 5
    std::cout << bad_counter(0) << std::endl;     // 0
    std::cout << bad_counter(101) << std::endl;   // 101
}

```

Обычно такие переменные помещаются в область глобальных переменных, поэтому на практике имеет смысл создавать
большие объекты именно таким способом, чтобы не тратить память на стэке.

Здесь можно встретить все проблемы, связанные с SIOF [билет 33](https://github.com/khbminus/CppTickets/blob/master/tickets/ticket33.md).
Про порядокс (или его отсутсвие инициализации таких переменных можно почитать [тут](https://en.cppreference.com/w/cpp/language/initialization#Non-local_variables))
и в билете про инициализацию


#### Dynamic storage duration

Программа сама полностью управляет временем жизни. При вызове оператора `new Type;` - создаётся
объект, значение этого выражения - указатель на него. Для того, чтобыы уничтожить объект используется
`delete ptr;`.

При попытке удалить объект 2 раза или удалить объект, созданый не при помощи опретаора `new` - 
возникает UB.
              
```c++

#include <vector>
#include "iostream"
struct Foo {
    std::vector<int> vec;
};

int main() {
    Foo *ptr = new Foo;
    int bar;
    std::cout << ptr->vec.size();
    delete ptr; // To avoid memory leak
    //delete ptr; // Double free - UB;
    //delete &bar; // UB;
}
```

Неосвобождённая память живёт до окончания программы - дальше современные ОС её освобождают. Такая ситуация называется утечкой памяти, 
она может вызвать отложенные проблемы.

Есть целый зоопарк new/delete; 

Можно выделять целые массивы при помощи `new Type[n]` - в таком случае освобождать память следует при помощи `delete[] ptr` - 
иначе UB (В том числе при попытке сделать `delete ptr;`). 

Для new работает много инициализаций:

* default - `new Type`
* default - `new Type()`
* default - `new Type{}`
* direct - `new Type(10)`
* direct list - `new Type{10}`

* Инициализация массивов - `new Foo[n]{val1, val2, val3}` - неинициализированные инициализируются по умолчанию.




### Время жизни временных объектов

Временные объекты умирают по завершении вычмсления выражения где они возникли, но при этом если создать
константную ссылку на временный объект, его время жизни продлится, чтобы соответсвовать времени жизни этой ссылки.

Важно, что эффект теряется, если мы инициализируем новую ссылку на временный объект старой.


```c++

const std::vector<int> &first = std::vectorP{0, 0, 0};
std::cout << first.size() << std::endl; // NO UB
 ....
// maybe another scope
const std::vector<int> &second = first; // would have been dangling if lifetime of second had been wider than lifetime of first;     
}
```

Это может иметь значение, если 


```c++
int const& func(int const& x) {
    return x;
} 


int main() {
    const int &first = func(1);
    std::cout << first; // UB
}
```
т.к. время жизни объекта продлевается только до времени жизни x. x - исчезает после завершения вычисления функции.

Подобное можно встретить и в STL - функция std::min - принимает и возвращает ссылки

```c++
int main() {
    const auto &val = std::min(0, 1); // Dangling reference
}
```
[ну или проблемы range-based for связанная с тем, что его рассахаривание - несколько выражений](https://github.com/Nekrolm/ubbook/blob/master/lifetime/for_loop.md) 
</details>

<details>
<summary>
 17. Указатели
</summary>


## Содержание

Каждый указатель относится к одному из 4 видов:
1. Указатель на объект или функцию.
2. Указатель на память следующую за последним элементом объекта.
3. Нулевой указатель - `nullptr`.
4. Invalid указатель - указывает куда угодно (мы не знаем, что в той памяти лежит).

* ## Базовый синтаксис
  * ### Объявление
    В общем случае выгладит так: `T *P`, где `T` - 
    это тип того, на что указатель указывает, `P` - это имя указателя.
    
    Примеры объявления (и инициализации в одном месте, а на самом месте в двух):
    ```c++
    const int ci = 10;       // просто cosnt int (не указатель)
    const int *pc = &ci;     // pс - указатель на переменную ci
    int i;                   // i - просто int (не указатель)
    int *p;                  // p - указатель (не инициализировали)
    
    struct node {
        int value;
        node *next, *prev;   // со структурками/классами синтаксис ровно такой же синтаксис
    };
    
    int main() {
    }
    ```
    
    >_Замечание:_ звездочка пишется именно перед указателем 
    (то есть для каждого указателя нужна отдельная звездочка)
    `node *next, *prev;`
    
    Приколы ([zero initialization](https://en.cppreference.com/w/cpp/language/zero_initialization)):
    ```c++
    int *ptr; // по-умолчанию ставится в nullptr (zero initialization)
              // кратко: nullptr ставится всем неинициализированным указателям со static storage duration
    
    int main() {
        int *another_ptr; // указывает на рандомное место в памяти (Invalid указатель)
    }
    ```

  * ### Разыменование
    
    Чтобы получить объект, на который ссылается указатель `ptr`, надо написать `*ptr`.

    >При разыменовании указателей вида 2,3,4 получаем UB.      

    Собственно, пример:
    ```c++
    #include <iostream>
      
    int *p;        			// просто указатель (nullptr по умолчанию)
    int x = 10;      		// просто int
    int *xp = &x; 			// xp с этого момента - указатель на x
      
    int main() {
      int y = *xp;          // в y копируем значение x
      int *nxp = xp;    	// nxp теперь тоже указатель на x
      
      std::cout << (*nxp) << " " << x << "\n";  // 10 10
      if (*nxp == x) {
          std::cout << "true\n";                // prints true
      }
    
      // int z = *p;      	// UB при разыминовании nullptr
      // int *p;         	// указатель p (invalid указатель)
      // *p;             	// тоже UB, потому что указатель - invalid
    }    
    ```
    >_Замечание:_ При выводе скобочки потерять нельзя из-за [приоритетов операторов](https://en.cppreference.com/w/cpp/language/operator_precedence).
  * ### Взятие адреса
        
    Собственно, чтобы получить адрес, на который указывает указатель `ptr`, 
    нужно написать `ptr` (то есть адрес, куда указывает указатель - это просто его значение).
  
    Пример:
    ```c++
    #include <iostream>
    
    int x = 10;        // просто int 
    int *px1 = &x;     // указатель на x
    int *px2 = &x;     // еще указатель на x
   
    int main() {
      std::cout << px1 << " " << px2 << "\n";    // выводим адреса переменной,
                                                 // на которую указывают px1 и px2
                                                 // (они совпадут)
      
      std::cout << &px1 << " " << &px2 << "\n";   // выводим адреса самих указателей
                                                  // (они разные) 
    }
    ```
    >_Замечание 1:_ `&ptr` - память, где лежит указатель. 
    `ptr` - память, где лежит переменная, на которую указывает указатель.   

  * ### Стрелочка `->`
    
    `->` - это просто синтаксический сахар для того, чтобы работать со структурками/классами
    было удобней.
  
    Написать стрелочку - то же самое, что и разыменовать указатель и применить к результату `operator.`.
    
    Пример:
    ```c++
    #include<iostream>
    
    struct node {            // структурка для двусвязного списка
      int data;              // значение node  
      node *next, *prev;     // указатели на предыдущий и следующий элементы списка
    }
    
    int main() {
      node a{10}, b{20}, c{30};  // создаем три элемента (пока что раздельных)
      a.prev = nullptr;          // говорим, что a - это начало списка, проинициализировав 
                                 // его предыдущий элемент nullptr (такой у нас инвариант)
      
      a.next = &b;               // связали элементы в список
      b.next = &c;               
      
      // теперь хотим вывести значение следующего элемента после a
      // давайте сделаем, как умеем
    
      std::cout << (*a.next).data << "\n";        // фуу
      
      // чтобы писать было на два символа короче, директор c++ придумал стрелочку:
    
      std::cout << a->data << "\n";               // теперь красиво 
    }              
    ```
  
* ## Реализация двусвязного списка
  Ну вот она:
  ```c++
  #include <iostream>
  
  struct node {
      int data;
      node *prev = nullptr, *next = nullptr;
  };
  
  void add_after(node& a, node&  b) {          // добавление элемента между a и a->next
      b.next = a.next;                         // говорим, что следующий за b элемент - это следующий за a в прошлом элемент
      if (b.next != nullptr) {                 // разыменование nullptr - UB
          b.next->prev = &b;                   // обновляем указатель на элемент идущий перед следующим за b
      }                                                                               
      a.next = &b;                             // все понятно: следующий за a теперь b
      b.prev = &a;                             // тоже понятно: предыдущий от b - это a
  }
  
  void add_before(node& a, node& b) {          // добавление элемента b между a->prev и a
      b.prev = a.prev;                         // элемент перед b теперь - это элемент перед a в прошлом
      if (b.prev != nullptr) {                 // разыменование nullptr - UB
          b.prev->next = &b;                   // обновляем указатель на идущий после элемента перед b
      }
      b.next = &a;                             // все понятно: следующий за b - теперь a
      a.prev = &b;                             // тоже понятно: следующий за a - теперь b
  }
  
  void remove(node& a) {                       // удаление элемента a 
      if (a.prev != nullptr) {                 // если есть элемент перед a, то обновим его
          a.prev->next = a.next;               // обновляем указатель на следующего за предыдущим элементом
      }
      if (a.next != nullptr) {                 // если есть элемент после a, то обновим его
          a.next->prev = a.prev;               // обновляем указатель на идущего пред слудющим за a
      }		
  }
  
  void print_list(node& head) {                // печть списка: не интеллектуально
      node *cur = &head;
      while (cur != nullptr) {                 // собственно, пока текущий выводмимый - не конец списка
          std::cout << cur->data << " ";       // выводим значение предыдущего head
          cur = cur->next;                     // теперь head - это следующий за head элемент
      }
      std::cout << "\n";                       // вывод пустой строчки, потому что почему бы и нет
  }
  
  int main() {
      node a{10}, b{20}, c{30}, d{40}, e{15};  // создание элементов и их связывание спомощью add-функций
      add_after(a, b);
      add_after(b, c);
      add_before(b, e);
      add_after(c, d);      
  
      print_list(a);  // 10 15 20 30 40
      print_list(b);  // 20 30 40
      print_list(c);  // 30 40
  
      remove(e);
  
      print_list(a);  // 10 20 30 40
  }
  ```
  >_Замечание:_ в конструкции типа `a.next->prev` мы сначала пишем точку, потому что `a` 
    был у нас не указателем, но, `a.next` - это указатель, поэтому, чтобы обратится к 
    его полям надо использовать стрелочку.
* ## Нулевой указатель
  Иногда хочется пометить, что указатель никуда не указывает. Это можно сделать с 
  помощью присвоения `nullptr` указателю. Такой указатель называется нулевым.
  > Разыменование нулевого указателя - это UB.
  
  Пример: 
  ```c++
  int main() {
    int *ptr = nullptr;
    if (ptr) {             // если ptr - это nullptr, то при конвертации к bool
                           // получим false. Иначе - true.
      // do something                  
    }
    if (ptr != nullptr) {  // так тоже делать никто не запрещает
      // do something
    }
    *ptr;                  // разыменование nullptr - UB
  }
  ```
  >_Замечание:_ Единственный случай, когда указатель при конвертации к `bool`
    вернет `false` - это случай, когда указатель нулевой.  
  
  До `C++11` стандартным нулевым указателем был макрос `NULL`, который определен нулем. 
  Ее лучше не использовать из-за вот таких приколов:
  ```c++
  #include <cstddef>
  #include <iostream>
   
  void foo(int*) {
    std::cout << "foo(int*);\n";
  }
   
  void foo(long) {
    std::cout << "foo(long);\n";
  }
   
  int main() {
    foo(nullptr);        // calls foo(int*)
    foo(NULL);           // compilation error (call is ambigous)
    foo(0);              // compilation error (call is ambigous)  
  }
  ```
  >_Замечание1:_ `NULL` и `0` могут быть сконвертированы и в `int`, и в указатель,
    а `nullptr` - это чисто про указатели.
  
  >_Замечание2:_ На cppreference [написано](https://en.cppreference.com/book/pointers#:~:text=Special%20null%20pointer),
    что `foo(NULL)` будет вызывать `foo(long)`, но у меня под всеми компиляторами и всеми разумными стандартами была ошибка компиляции.
  
  > _Замечаание3 (от ХБ):_ лично у меня при компиляции руками `g++ -std=c++17/03/11` g++ выкидывал предупреждение, что `NULL` кастуется к лонгу, при этом `clang++` вообще ничего не выкидывал. 
  
  Тем не менее, когда вы пишете `foo(NULL)`, вы ожидаете, что вызовется перегрузка `foo(int*)`, чего не происходит.
* ## Отличие ссылок от указателей
  * ### Изменяемость
    
    >Ссылка после создания всегда указывает на один элемент, в то время как указатель 
    можно перепривязывать.
    
    Пример:
    ```c++
    #include <iostream>
    
    int main() {
      int x = 10;
      int y = 20;
      int *ptr = &x;                             // указатель на x
      int &x_ref = x;                            // ссылка на x 
      std::cout << ptr << " " << &x_ref << "\n"; // указывают на одну и ту же память
      ptr = &y;                                  // перепривязали указатель к y
      x_ref = y;                                 // это уже присвоение y в x_ref, т.е. в x
      std::cout << ptr << " " << &x_ref << "\n"; // у ptr адрес поменялся на адрес y, а у x_ref остался тем же
    }
    ```
  * ### Обнуляемость
    
    >Указатели имеют нулевое состояние `nullptr`, в то время как ссылки таким не обладают. 
    Т.е. ссылка всегда должна указывать на объект, а указатель - нет.
    
    Пример:
    ```c++
    #include <iostream>
    
    int *g_ptr;                 // просто указатель (по умолчанию nullptr)
    
    int main() {
      int *ptr = nullptr;       // просто нулевой указатель
      int &ref;                 // compilation error: ref объявлена, как ссылка, но не инициализирована  
    }
    ```
  * ### Хранение в контейнерах
    Указатели спокойно кладутся в контейнеры, а вот ссылки туда класть нельзя. 
    (можно, если использовать `std::reference_wrapper`, который превращает ссылку в 
     копируемый и присваиваемый объект, но это не просто ссылки)
    
    >Ссылки нельзя копировать и присваивать. (Вообще ссылка - это не объект, 
     а в контейнерах должны объекты лежать)
  
    Пример:
    ```c++
    #include <vector>
    
    int main() {
      std::vector<int*> v_ptr(10);       // создается вектор из 10 нулевых указателей
      std::vector<int&> v_ref(10);       // compilation error: с длинной ошибкой
    }
    ```
    
    Пример с `std::reference_wrapper`:
    
* ## Арифметика указателей
  * ### `array-to-pointer decay`
    Ссылка на массив - это ссылка на его первый элемент. Значит можно сделать вот так:
    
    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
  
    int main() {
      int data[]{10, 20, 30, 40};
      
      int *p1 = &data[0];        // берем адрес первого элемента
      assert(*p1 == 10);
  
      int *p2 = data;            // array-to-pointer decay. Только массивы, не вектора.
      assert(p2 == p1);
      assert(*p2 == 10);
      *p2 = 12;                  // можно менять
      assert(*p2 == 12);
      assert(data[0] == 12);
      *p2 = 10;
    }
    ```
    >_Замечание:_ Только для C-шных массивов (не для векторов).
    
  * ### Операции `+`, `++`, `-`, `--` указателей с `int`
    Указатели в массиве можно смещать (главное, надо остаться либо в массиве,
    в котором мы находились, либо в следующей ячейке после конца массива). Отдельные объекты
    трактуются, как массивы из одного элемента, то есть можно получать указатель следующий за последним.
    
    `+`, `++` - смещение вперед.
    
    `-`, `--` - смещение назад.
  
    >Работает ровно как у итераторов.
    
    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
  
    int main() {
      int data[]{10, 20, 30, 40};
      
      int *p1 = &data[0];               // взяли указатель на первый элемент
      int *p2 = data;                   // array-to-pointer decay
  
      // Арифметика такая же, как и у итераторов.
    
      int *q = p1 + 2;                  // указатель на data[2]
      assert(q == &data[2]);
      assert(data + 2 == &data[2]);
      assert(*q == 30);
  
      int *r = q;                       // указатель на q, то есть на data[2]
      r--;                              // теперь это указатель на data[1]
      assert(r == &data[1]);
      assert(*r == 20);
  
      int x = *r--;                   
      
      // Эквивалентно вот этой штуке:
      // int *old_r = r;
      // r--;
      // int x = *old_r;
      
      assert(x == 20);
      assert(data[1] == 20);
      assert(data[0] == 10);
      assert(r == &data[0]);
      assert(*r == 10);
  
      // То же самое, только с префиксным оператором
    
      r = &data[1];
      int y = *--r;
      assert(y == data[0]);
      assert(y == 10);
      assert(r == &data[0]);
  
      std::ptrdiff_t diff = r - q;      // std::ptrdiff_t - тип, в который влазит вся память на компе
      assert(diff == -2);
      assert(&data[0] - &data[2] == -2);
  
      assert(data[1] == *(data + 1));  // По определению, синтаксический сахар для массивов (not vectors).
      assert(data[1] == *(1 + data));
      assert(1[data] == *(1 + data));
      int *data_ptr = data;
      assert(data_ptr[1] == *(data_ptr + 1));
      assert(data_ptr[1] == data[1]);
    }
    ```
    >_Замечание:_ `data[1]` - это на самом деле `*(data + 1)`.
  * ### `one-past-the-last`
    > Указатель на память, следующую за последним элементом массива - корректный, но его нельзя разыменовывать.
    
    Пример:
    ```c++
    #include <cassert>
    #include <cstddef>
    #include <iostream>
  
    struct Foo {
      int x = 0;
      int y = 1;
    };
    
    int main() {
      int data[]{40, 20, 10, 30};
  
      int *one_past_end = data + 4;
      assert(one_past_end - data == 4);
      // int var = *one_past_end;                     // разыменование - UB.
        
      Foo a;
      int *val = &a.x;
      val++;                                          // корректно (ope-past-the-last)
      // *val;                                        // разыменование - UB
    }
    ```
  * ### Сравнение указателей
    >`=`,`!=` - можно сравнивать любый указатели. Возвращает, равен ли один другому.
    
    > `>`,`>=`,`<`,`<=` - можно сравнивать указатели из одного массива или из одной структурки. 
      В случае сравнения разных объектов - `unspecified behaviour`.
    
    > `-`: Вычитать два указателя можно только из одного массива
  
    >В контейнерах используется `std::less`, который на всех указателях строит _какой-то_ полный порядок,
      поэтому можно пихать указатели, например, в `std::set`.
    
    Пример:
    ```c++
    #include <cassert>
    #include <functional>
    #include <iostream>
    #include <set>
  
    struct Foo {
      int a = 10;
      int b = 20;
      int c = 30;
    };
  
    int main() {
      {
          int data[4];
          int end;
          std::cout << (&end - data) << "\n";  // UB
          std::cout << (data < &end) << "\n";  // unspecified, может быть неконсистентным!
          std::cout << (data < &end) << "\n";  // unspecified, может быть неконсистентным!
          assert(data != &end);  // ok
      }
      {
        Foo f;
        std::cout << &f.b - &f.a << "\n";  // UB: не массив
        assert(&f.a < &f.b);  // ok: члены с одним уровнем доступа (private/protected/public) упорядочены
        assert(&f.a != &f.b);  // ok: разные int
      }
      {
        std::set<int*> s;
        int a = 10, b = 20;
        s.insert(&a);  // ok
        s.insert(&b);  // ok
  
        std::less<int*> comparator;
        std::cout << comparator(&a, &b) << "\n";  // implementation-defined
      }
    }
    ```

* ## C-style-strings/ASCIIZ-строки/строки в стиле Си
  * ### Определение
    `C-style-strings` - это не тип, а конвенция. 
     > "Если у нас есть массив, где сначала идут символы, символы, символы, а потом символ `\0`,
        то это сишная строка", — Егор Суворов.
  * ### Сохранение строкового литерала в `char *`
    С помощью `array-to-pointer decay` можно сконвертировать массив (сишную строку) в указатель.
    
    Пример:
    ```c++
    int main() {
      char str[] = "hello";                              // сишная строка
      // char str[] = {'h', 'e', 'l', 'l', 'o', 0};      // то же самое
      
      char str_ptr = *str;                               // array-to-pointer decay
    }
    ```
  * ### Сравнение и получение длины
      
    >_Опасно:_ если есть две си-шные строки `s` и `t`, то если написать `a < b`, то будут сравниваться указатели, 
      что приведет к `unspecified behaviour`. 
      
    >_Опасно:_ казалось бы на равенство указатели сравниваются без `unspecified behaviour`,
      почему бы тогда не сравнить `s == t`. Нельзя так как не гарантируется, что у 
      одинаковых строковых литералов один и тот же адрес. Ну и вообще разные строковые
      литералы могут обозначать одну и ту же сишную строку (например `"hello"` и `"hello\0"`). 
      То есть придется тоже цикликом.
      
    Но если написать `*a < *b`, то сравнятся лишь первые символы, а значит придется писать цикл `:(`.
      
    Сравнение на меньше (остальные аналогично):
    ```c++
    bool is_less(char* a, char* b) {
      for (int i = 0; a[i] || b[i]; i++) {           // (a[i] || b[i]) - нулевой символ кастуется к false, остальные - к true
        if (a[i] != b[i]) {
          return a[i] < b[i];
        }
      }
      return false;
    }
    ```
      
    Получить длину сишной строки можно так:
    ```c++
    int get_length(char* s) {
      int res = 0;
      while (s[res] != '\0') {    // идем до последнего символа, ответ - сколько элементов прошли
        res++;
      }
      return res;
    }
    ```
      
    >_Опасно:_ длина сишной строки считается за линию. Даже `std::strlen()`.
      
  * ### Выделение памяти, аллокация, конкатенация {#oper}
      
    Мы хотим сконкатенировать две сишные строки. Беда в том, что сишные строки - 
    это не отдельные объекты, это указатели.
      
    То есть если мы хотим сконкатенировать две строки и получить новую, то нам надо 
    где-то выделить под нее память.
      
    Функция для конкатенации: 
    ```c++
    char* strcat(cosnt char* a, const char* b) {
      char* res = new char[std::strlen(a) + std::strlen(b) + 1]; // +1 для '\0'.
      int res_len = 0;
      for (int i = 0; a[i]; i++) {
        res[res_len++] = a[i];
      }
      for (int i = 0; b[i]; i++) {
        res[res_len++] = b[i];
      }
      res[res_len] = '\0';
      return res;
    }
    ```
      
    >_Опасно:_ теперь про каждую сишную строчку мы обязаны помнить, как мы ее получили.
      В зависимости от способа получение вызывать нужный `delete`.
      
    Пример (реализацию `strcat` возьмем из прошлого примера):
    ```c++
    #include <cstring>
    #include <iostream>
    #inlude "прошлый_пример.h"
      
    int main() {
      char* x = "xyz";
      char* y = strcat("xy", "z") + 1;
      
      // миллион строк кода
      
      delete[] (y - 1); // тут надо не забыть, что мы выделили именно массив и y взят со съездом на 1
      
      // еще надо не забыть, что вызывать delete от x не надо, потому что
      // у x automatic storage duration
    }
    ```
    
  * ### Небезопасность функции чтения

    Рассмотрим реализацию `readWord` из известного среди всей прогрессивной общественности 
    файлика `optimization.h`.
  
    Напоминание реализации readWord:
    ```c++
    void readWord(char *s) {
      int c = readChar();         // readChar просто смотрит на текущий символ из буфера
      while (c > 32)
        *s++ = c, c = getChar();  // c++ выпендреж от Cерёжи. Просто считали очередной символ.
      return с != -1;             // видимо, возвращает, считалось ли что-то?
    }
    ```
    
    >_Опасно:_ что произойдет, если мы считаем больше символов, чем выделено в `s`? 
      UB конечно же.
  
  * ### Кто владеет результатом `c_str`
    
    Что вообще такое `c_str`? Это метод у `std::string`, который возвращает сишную строчки.
    
    >_Собственно ответ:_ результатом `c_str` владеет `std::string`, который его вызвал.
    
    Пример:
    ```c++
    #include <iostream>
    #include <string>
    
    int main() {
      const char *s_ptr;
      {
        std::string s = "hello";
        s_ptr = s.c_str();
        std::cout << s_ptr << " (1)\n";    // корректно вывели сишную строчку
      }                                    // конец зоны видимости s (тут она умирает)
      std::cout << s_ptr << " (2)\n";      // UB: строчка, владеющая той памятью уже не существует
    }
    ```</details>

<details>
<summary>
</summary>


**Важно знать**: порядок инициализации переменных между единицами трансляции неопределен!

### Что делает #include, в том числе #include <iostream> и `#include <iosfwd>`:

1) `#include "header.h"/<lib>` - просто вставляет код из `header.h/lib` в текущую единицу трансляции
2) `#include <iostream>` - включает стандартную библиотеку ввода/вывода в текущую единицу трансляции (`<>` - используются для встроенных библиотек, `""` - для собственных header-файлов)
3) `#include <iosfwd>` - этот заголовок содержит forward declaration для стандартной библиотеки ввода/вывода.



### Мотивация:
1. Зачем линковка, когда есть `#include`, отличия:

	**При линковке** мы можем сначала скомпилировать все файлы отдельно друг от друга, получив объектные файлы, а затем слинковать их как захотим. Например, есть файл `main.cpp`, он вызывает `print()` функцию. Мы можем создать 2 файла `print1.cpp` и `print2.cpp`, сделать независимо компиляцию каждого (`g++ -c main.cpp print1.cpp print2.cpp`), а далее слинковать полученные `main.o` и `print1/2.o` попарно (`g++ main.o print1.o -o a.exe`, `g++ main.o print2.o -o b.exe`), так получаем 2 `exe`-файлика, которые используют разные функции.

	Также важно помнить, что функция может иметь ровно определение (по правилу `ODR - One Definition Rule`) в какой-либо единице трансляции (definition: тело функции `void foo() {...}`), но сколько угодно много объявлений (declaration: `void foo();`). Структуры могут иметь определения для своих методов в разных единицах трансляций, но эти определения должны полностью совпадать (в таких случаях делают header-файл c объявлением структуры и ее полей/методов, а в отдельной одной единице трансляции пишут определения для методов).

	`#include<something>` - просто скопирует содержимое файла `something` и вставит в файл с include'ом, при этом размер текущего файла увеличится.


### Единицы трансляции и файлы:
`.cpp`-файл - это `translation unit` (единица трансляции), код разбивается на несколько файлов, чтобы было удобнее его читать + компилировать каждый файл отдельно (`g++ -c main.cpp` - создаст объектный (бинарный) файл `main.o`).


**UB:** 
	
1. Разные параметры по умолчанию в объявлении и определении функций
	
2. Разные типы данных в объявлении и определении, возвращаемые функцией


### Как из одного файла заиспользовать глобальный класс/функцию из другого:

1. **Функции**: в 1 единице трансляции мы определяем функцию (function definition: `void foo(int x) {[body of the function foo]}`), во всех других только пишем объявление этой функции (function declaration: `void foo(int x);`)

2.1. **Классы/структуры**: если не использовать `header`-файлы, то это боль, нужно в каждой единице трансляции *заново прописывать **определения членов** структуры* и **объявления ИЛИ определения методов (при этом определения в разных единицах трансляции должны совпадать - copy-paste)**; тут легко напороться на `UB`, поменяв местами определения членов структуры (UB так как удаляет объект текущая единица трансляции, поэтому если поля имеют другое расположение, то порядок удаления полей не соответствует их расположению в памяти). Вот [пример кода с лекции](https://github.com/hse-spb-2021-cpp/lectures/tree/master/06-211006/08-struct-ub).

2.2. **Классы/структуры**: с использованием header-файлов все просто: мы 1 раз *объявляем* все поля/методы структуры в каком-нибудь `my_struct.h` файле, далее в 1 единице трансляции (`my_struct.cpp`) пишем определения для методов. Если в каком-либо файле нам понадобиться эта структура, то мы просто включаем ее в нужный файл `#include "my_struct.h"` (при этом не забываем про `guards` в header-файлах).
	


### External linkage/internal linkage:

`Internal linkage` - данный тип линковки обозначает, что сущность (переменная, функция, структура) будет видна только в данной единице трансляции (в текущем `.cpp`-файле).

`External linkage` - данный тип линковки обозначает, что сущность будет видна всем единицам трансляции, которые мы решили скомпилировать вместе. Другими словами, доступна через всю программу, которая представляет собой комбинацию всех единиц трансляции.


1. **Слово `static` и `unnamed namespace`, где применять:**

1) `static`: если мы хотим, чтобы *глобальная функция* была видна только в текущей единице трансляции, то мы может перед ее типом написать слово `static`, и данная функция не будет видна другим единицам трансляции (также `static` делаем сущность *статической*, то есть она инициализируется в программе 1 раз и не умирает до завершения самой программы). Примеры:

```cpp
// foo.cpp

static int foo() {
	return 100;
}

int bar() {
	return 100;
}
```

```cpp
// main.cpp

foo();
bar();

int main() {
	foo(); // ERROR: undefined reference
	bar(); // works fine
}
```

2) `unnamed namespace`: нужен, чтобы переменная/функция/сущность была долступна только текущей единице трансляции. Пример:

```cpp
// foo.cpp
namespace {
	int foo() {
		return 10;
	}
}

int calc() {
	int x = foo();
	return x * x;
}
```

```cpp
// main.cpp

int foo();
int calc();

int main() {
	foo(); // ERROR
	calc(); // works fine
}
```





### Формулировка `One Definition Rule`, формулировка `IFNDR` (**Ill-Formed, No Diagnostic Required**):
	
1. **Формулировка `One Definition Rule`:** у любой сущности (функции/глобальной переменной) должно быть ровно 1 определение на всю программу (программа - все translation units, что есть в проекте)

2. **Формулировка `IFNDR`:** есть сущность имеет не 1 определение, то возникнет UB сразу после запуска программы (даже до выполнения main()), компилятор не обязан сообщать о некорректности программы

	
1) Пример ошибок линковщика: `multiple definition`, `undefined reference`:
```cpp
// multiple definition example: - имеем несколько определений для сущности

// foo.cpp
void foo() {...}
```

```cpp

// main.cpp
void foo() {...}

int main() {
}

// compile both and you will get an error: 

// g++ main.cpp foo.cpp;
// ./a.exe -> ERROR: multiple definition of 'foo()'
```

```cpp
// undefined reference example: - не имеем ни одно определения для сущности, однако пользуемся ею

// foo.cpp - leave empty
```

```cpp
// main.cpp

void foo();

int main() {
	foo();
}
// complie both and error will occur: 

// g++ main.cpp foo.cpp;
// ./a.exe -> ERROR: undefined reference to 'foo()'
```

2) Что происходит с перегрузками функций: перегрузки разрешаются на уровне компилятора, а не линковщика, поэтому **иметь одну функцию с разными перегрузками нормально**:

```cpp

// foo.cpp
void foo(int x) {...}
```

```cpp
// main.cpp
void foo(int x);
void foo() {...}

int main() {
	foo(10);
	foo();
}
// works fine, no ODR violation
``` 



### Типичный заголовочный файл:

1. Конвенция именования заголовочных файлов: 

	Правильное название для `guard'a` в `header`-файле будет `[filename uppercased]_H_` (здесь `[filename uppercased]` - название текущего файла, в котором пишется `guard`, заглавными буквами).

2. `Include guards`: зачем, как правильно, осторожно с `_`:
		
	Если начать название `guard'а` с `_A`, `__A` (`A` - любая заглавная буква), то это `UB` (такие названия запрещены к использованию).


**`Note:`** 

Если не делать `include-guards`, то возможна ситуация: мы имеем структуру `Foo` в `"header1.h"` файле, далее мы написали `#include "header1.h"` в каком-нибудь `"header2.h"` файле, а затем в `main.cpp` сделали `#include "header1.h"` и `#include "header2.h"`, так мы получили ошибку `"multiple definition of struct Foo"`, чтобы такого не произошло делают следующее:

```cpp
#ifndef HEADER1_H_
#define HEADER1_H_

struct Foo {...};

#endif // HEADER1_H_

// Так при первом включении header1.h в main.cpp мы объявим HEADER1_H_ и при втором include в header2.h второго подключения не случится

```


3. Опасность неявного включения, концепция include what you use, примеры из стандартной библиотеки вашего компилятора (`exercises/01-210906/07-missing-include`):

	Опасность неявного включения: на различных компиляторах код может либо компилироваться, либо нет. (смотри [exercises/01-210906/07-missing-include](https://github.com/hse-spb-2021-cpp/exercises/blob/master/01-210906/07-missing-include.cpp)).

	Важно сделать так, чтобы порядок `#include`-ов в единице трансляции не имел значения и все .h-файлы были независмые, поэтому если в каком-то .h-файлы мы используем что-то из другого .h-файла, то мы обязаны в текущий заголовочный файл включить все header-файлы, что необходимы (принцип `include what you see`); [пример с лекции](https://github.com/hse-spb-2021-cpp/lectures/tree/master/06-211006/10-include).


4. Запрет на реализацию функций:

	Мы пишем только объявления функций в `header`-файлах (так принято делать, чтобы избежать `ODR`). Также можно использовать `inline`, но **не нужно**, так как считается **плохой практикой** 
		
	Смысл `inline`: функция может иметь несколько определений, но я, как программист, обещаю, что все эти определения равны, поэтому выбери любое.


5. Необходимость подключать заголовочный файл в файл с реализацией:

	В файл реализации мы должны подключить наш `.h`-файл, чтобы обезопасить себя от возможных `UB`, пример:

```cpp
// get.h

#ifndef GET_H_
#define GET_H_

float get(int x);

#endif
```

```cpp
// get.cpp

double get(int x) {
	...
}
```

```cpp
// main.cpp

#include "get.h"

int main() {
	get(10.0);
}

// g++ main.cpp get.cpp -o a.exe
// ./a.exe - UB!
```

Если в пример выше включить `get.h` файл в `get.cpp`, то компилятор выдаст ошибку компиляции, т.е. убережет от трудного `debugging'а`.





### Взаимная рекурсия между заголовками и `forward header`:
	
**Взаимная рекурсия:**

Проблема:

```cpp
// bar.h 

#ifndef BAR_H_
#define BAR_H_

#include "foo.h"

struct Bar {
    Foo *f;
};

void bar_do_something(Foo, Bar);

#endif  // BAR_H_

```

```cpp
// foo.h

#ifndef FOO_H_
#define FOO_H_

#include "bar.h"

struct Foo {
    Bar b{this};
};

#endif  // FOO_H_

// Здесь Bar не видит Foo, так как стоят guards, если убрать guards, то мы зациклим подключения
```

Решение:

```cpp
// Чтобы решить проблему, мы создаем foo_fwd.h файл, в котором не будет ничего кроме объявления структуры Foo: struct Foo;

// foo_fwd.h

#ifndef FOO_FWD_H_
#define FOO_FWD_H_

struct Foo;

#endif  // FOO_FWD_H_
```

#### Идея `forward header`:
Данные заголовочные файлы включают в себя только forward-declaration (то есть объявления) структур.

Если есть `foo_fwd.h` и `foo.h`, то в `foo.h` также нужно подключить `foo_fwd.h`, чтобы проверить, что у нас объявление и определения не отличаются типом данных, параметрами и тд.



1. Incomplete type: как объявить, что можно сделать с неполным типом: 

	1) Синтаксис: `struct Foo;`

	2) Неполного типа достаточно, что передавать указатели и ссылки на структуру, т.е. мы не выделяем память для новой структуры данного типа. Но ничего кроме как передать по ссылке/значению мы не умеем: не можем вызывать методы, обжащаться к полям, создавать instance данной структуры, так как мы не знаем сколько структура должна занимать памяти, а также не знаем какие поля и методы у нее определены, [код с лекции](https://github.com/hse-spb-2021-cpp/lectures/tree/master/06-211006/09-incomplete).

	3) Зачем надо: это укоряет компиляцию, так как нам не нужно парсить определение структуры.

	
2. Пример forward hearder из стандартной библиотеки (`<iosfwd>`):

	1. Если мы хотим для свой структуры реализовать оператор вывода, то нам необязательно в .h-файл подключать большую <iostream> библиотеку, мы можем просто объявить, что объект ios существует и все:

```cpp
// foo.h

#ifndef FOO_H_
#define FOO_H_

#include <iosfwd>

struct Foo {};

std::ostream& operator<<(std::ostream&, const Foo&);

#endif  // FOO_H_
```

```cpp
// foo.cpp
#include "foo.h"
#include <iostream>

std::ostream& operator<<(std::ostream& os, const Foo&) {
	return os << "hello world";
}
```




### Что обычно (не) пишут в своих заголовочных файлах (в том числе forward), `using namespace std`:

1. В заголовках **не пишут** определения функций, их выносят в соответствующие .cpp-файлы.

2. В заголовках **пишут** объявления сущностей, guards

3. В forward-заголовках пишут forward-declaration для структур (`struct Foo;`)

4. `using namespace std` - так не пишем, так как в случае, если есть какая-либо функция c совпадающим названием как в `std` в другой библиотеке, мы не сможем ее вызвать. 







## Other notes from `06-211006(I) — программы из нескольких файлов, СПб ВШЭ ПМИ, C++`:

### `namespaces`: 

1. `::` - global namespace.

2. `ns1::ns2` - nested namespace.

3. Поиск среди namespace'ов вверх по вложенности.

4. `(Un)qualified name lookup`:

```cpp
namespace ns1 {
	void foo() {...}
}

namespace ns1::ns2 {
	void bar() {
		foo(); // Unqualified name lookup for 'foo' - пытаемся найти foo() в текущем namespace'e потом на 1 уровень выше, потом на 2 выше и тд
		
		ns1::foo(); // Qualified name lookup for 'foo', Unqualified name lookup for 'ns1'
	}
}
```

5. `Argument dependent lookup`:

```cpp
namespace ns {
	struct Foo;

	void foo(Foo) {...}

	void foo() {...}
}

// compiles fine
int main() {
	ns::Foo f;
	foo(f); // найдет нужный 'foo' в 'ns', так как компилятор пытается посмотреть во все namespace'ы и найти там функцию foo с такими аргументами
	
	// это нужно, чтобы уметь писать операторы: f == f, ns::operator==(f, f) 
}

// does not compile
int main() {
	foo();
}

```
</details>

<details>
<summary>
 Static initialization order fiasco
</summary>

### О чём это
Рассмотрим программу, состоящую из нескольких единиц трансляции: `a.cpp` и `b.cpp`. Пусть в `a.cpp` и `b.cpp` создаются объекты с статическим временем жизни (см. [билет 15](https://github.com/khbminus/CppTickets/blob/master/tickets/ticket15.md#static-storage-duration)), например глобальные переменные. В таком случае порядок инициализации этих переменных зависит от порядка линковки этих единиц трансляции. Это может привести к проблемам.
<!-- TODO: make references to other tickets uniform --->
### Создание и уничтожение объектов со статическим временем жизни
В целом, объекты с static storage duration инициализируются при запуске программы (в каком-то порядке) и удаляются по завершению программы (в неочевидном порядке<sup>[1](https://www.youtube.com/watch?v=XdrSzs04HKU&list=PL8a-dtqmQc8obAqSKqGkau8qiafPRCxV7&t=4806s)</sup> <sup>[2](https://stackoverflow.com/questions/31443437/why-is-the-order-of-destruction-of-these-function-local-static-objects-not-the-i)</sup>, под разными компиляторами по-разному). Также стандарт C++ гарантирует, что все static storage duration объекты внутри одной единицы трансляции будут проинициализированы по порядку<sup>[3](https://en.cppreference.com/w/cpp/language/initialization#:~:text=initialization%20of%20these%20variables%20is%20always%20sequenced%20in%20exact%20order%20their%20definitions%20appear%20in%20the%20source%20code.)</sup>, но нет никаких гарантий про порядок между ними! 
#### У кого static storage duration
Есть деление на два типа<sup>[4](https://en.cppreference.com/w/cpp/language/storage_duration#:~:text=static%20or%20extern.-,See%20Non%2Dlocal%20variables%20and%20Static%20local%20variables%20for%20details%20on%20initialization%20of%20objects%20with%20this%20storage%20duration.,-thread%20storage%20duration)</sup>: *non-local* переменные (в сущности, глобальные или статические поля класса) и *static local* переменные (статические локальные).
##### Non-local
К примеру, обычные глобальные переменные.
```c++
int x = 1;

void foo() {
    x++;
}

int main() {
    std::cout << x << '\n';  // 1
    foo();
    std::cout << x << '\n';  // 2
    x += 2;
    std::cout << x << '\n';  // 4
}
```
Как правило, они инициализируются во время запуска программы. Однако в случае non-local переменных, если применимо *constant initialization*<sup>[5](https://en.cppreference.com/w/cpp/language/constant_initialization)</sup>, то компилятор может (но не обязан, хотя обычно так и есть) создать объект сразу на этапе компиляции! Таким образом, объект будет встроен в .exe файл, из-за чего он может раздуться.

Если же constant initialization не применимо, то сначала используется *Zero initialization*<sup>[6](https://en.cppreference.com/w/cpp/language/zero_initialization)</sup>:
```c++
struct A {
    int a,b,c;
};
 
double f[3]; // zero-initialized to three 0.0's
int* p; // zero-initialized to null pointer value (even if the value is not integral 0)
std::string s; // zero-initialized to indeterminate value
               // then default-initialized to "" by the std::string default constructor
int main(int argc, char*[])
{
    delete p; // safe to delete a null pointer
    static int n = argc; // zero-initialized to 0 then copy-initialized to argc
    std::cout << "n = " << n << '\n';
    A a = A(); // the effect is same as: A a{}; or A a = {};
    std::cout << "a = {" << a.a << ' ' << a.b << ' ' << a.c << "}\n";
}
```

После *Zero initialization* идёт *Dynamic initialization*<sup>[7](https://en.cppreference.com/w/cpp/language/initialization#Dynamic_initialization)</sup>, собственно присвоение значений.

Компилятор имеет право сделать *Early Dynamic initialization*<sup>[8](https://en.cppreference.com/w/cpp/language/initialization#Early_dynamic_initialization)</sup>, обычно на этапе компиляции, если он видит, что объект не меняет другие объекты и не зависит от других не *early dynamic initialized*.
```c++
inline double fd() { return 1.0; }
extern double d1;
double d2 = d1;   // unspecified:
                  // dynamically initialized to 0.0 if d1 is dynamically initialized, or
                  // dynamically initialized to 1.0 if d1 is statically initialized, or
                  // statically initialized to 0.0 (because that would be its value
                  // if both variables were dynamically initialized)
double d1 = fd(); // may be initialized statically or dynamically to 1.0
```
Тут вообще много всего интересного и запутанного. Если есть время, посмотрите [cppreference](https://en.cppreference.com/w/cpp/language/initialization).
##### Static local
Статические локальные переменные можно создавать внутри функций, тогда они будут доступны каждый раз, когда вызывается эта функция.
```c++
int foo() {
    static int x = 1;
    x++;
}

int main() {
    std::cout << x << '\n';  // 1
    foo();
    std::cout << x << '\n';  // 2
    x += 2;
    std::cout << x << '\n';  // 4
}
```
Инициализируется такой объект единожды первый раз, когда он используется в функции.
### Пример static initialization order fiasco
Из-за того, что порядок инициализации зависит от порядка линковки, можно наткнуться на проблемы, если один объект при своей инициализации (обычно в конструкторе) использует другой объект, который сам ещё не создался.

Это и называется static initialization order fiasco (SIOF).
#### Пример с некорректным порядком
`a.h`
```c++
#ifndef HSE_CPP_EXAM_A_H
#define HSE_CPP_EXAM_A_H

#include <vector>

struct Counter {
    explicit Counter (int init_count) : count(init_count) {}

    int getID() {
        return count++;
    }
    int count;
};

extern Counter globalCounter;

#endif //HSE_CPP_EXAM_A_H 
```

`a.cpp`
```c++
#include <vector>
#include "a.h"

Counter globalCounter(100);
```
`main.cpp`
```c++
#include <iostream>
#include "a.h"

int someId = globalCounter.getID();

int main() {
    std::cout << someId << '\n';  // either 100 or uninitialized
}
```
Если скомпилировать файлы в порядке `g++ a.cpp main.cpp -o siof`, то всё будет хорошо. Если же `g++ main.cpp a.cpp -o siof`, то `someId` не сможет воспользоваться `globalCounter`.
#### Пример, где не существует корректного порядка
`a.h`
```c++
#ifndef HSE_CPP_EXAM_A_H
#define HSE_CPP_EXAM_A_H

#include <utility>
#include <vector>
#include <iostream>

struct Counter {
    explicit Counter (int init_count, std::string name) : count(init_count), name(std::move(name)) {}

    int getID() {
        return count++;
    }

    int count;
    std::string name;
};

extern Counter globalCounter;

#endif //HSE_CPP_EXAM_A_H
```
`a.cpp`
```c++
#include "a.h"
#include "b.h"

Counter globalCounter(100, globalNameGiver.getName());
```
`b.h`
```c++
#ifndef HSE_CPP_EXAM_B_H
#define HSE_CPP_EXAM_B_H

struct NameGiver {
    explicit NameGiver(int id) : id(id) {}

    std::string getName() {
        return "obj" + std::to_string(id);
    }

    int id;
};

extern NameGiver globalNameGiver;

#endif //HSE_CPP_EXAM_B_H
```
`b.cpp`
```c++
#include "a.h"
#include "b.h"

NameGiver globalNameGiver(globalCounter.getID());
```
`main.cpp`
```c++
#include <iostream>
#include "a.h"
#include "b.h"

static int someId = globalNameGiver.id;
static std::string someName = globalCounter.name;

int main() {
    std::cout << someId << '\n';  // ???
    std::cout << someName << '\n';  // ???
}
```
`globalCounter` нужен для создания `globalNameGiver`, а `globalNameGiver` нужен для создания `globalCounter`... Вопрос о курице и яйце без решения.
#### Пример, где возникает UB только через std::vector
Давайте в модуль положим вектор, значение которого инициализируем только в `a.cpp`.

`a.h`
```c++
#ifndef HSE_CPP_EXAM_A_H
#define HSE_CPP_EXAM_A_H

#include <vector>

struct Foo {
    static std::vector<int> a;
};
// or use extern instead of Foo

#endif //HSE_CPP_EXAM_A_H
```
`a.cpp`
```c++
#include <vector>
#include "a.h"

std::vector<int> Foo::a{1, 2, 3};
```
`main.cpp`
```c++
#include <iostream>
#include "a.h"

int first_of_a = Foo::a[0];

int main() {
    std::cout << first_of_a << '\n';  // either 1, or UB, as it's out-of-bounds
}
```
Если сначала инициализируются объекты из `main.cpp`, то `first_of_a` должно взять значение неинициализированного вектора, получая UB.
### Решение проблемы
Чтобы избежать этой проблемы, можно воспользоваться идиомой 'construct on first use': вместо `non-local` переменных, будем использовать `static local`, чтобы они гарантированно создались, когда мы ими воспользовались.

Например, для прошлого примера:

`a.h`
```c++
#ifndef HSE_CPP_EXAM_A_H
#define HSE_CPP_EXAM_A_H

#include <vector>

struct Foo {
    static std::vector<int>& getVector();
};

#endif //HSE_CPP_EXAM_A_H
```
`a.cpp`
```c++
#include <vector>
#include "a.h"

std::vector<int>& Foo::getVector() {
    static std::vector<int> a{1, 2, 3};
    return a;
}
```
`main.cpp`
```c++
#include <iostream>
#include "a.h"

int first_of_a = Foo::getVector()[0];

int main() {
    std::cout << first_of_a << '\n';  // now OK!
}
```
#### Сравнение с автоматическим временем жизни и динамическим
* В отличие от автоматического времени жизни, один и тот же объект может использоваться в разных единицах трансляции.
* В отличие от динамического времени жизни, такой способ безопаснее, потому что гарантируется, что объект живой.

### Замечания
* Циклическое SIOF починить не получится никак, так как оно циклическое...
* Такие же приколы могут быть с уничтожением объектов: может удалится объект, нужный другому в деструкторе. Такое можно решать, например, вообще никогда не удаляя объект:
```c++
Foo& getFoo() {
    static auto* ptr = new Foo();  // never destructs!
    return *ptr;
}
```
* `cin`, `cout` тоже глобальные переменные, поэтому если вы используете их в конструкторе, то теоретически могут быть такие же проблемы. Однако, начиная с C++11, гарантируется, что `cout`, `cin` и прочие создадутся раньше остальных объектов с статическим временем жизни. **Только в случае если `#include <iostream>` идёт до `#include` файла с объявлением**. Об этом можно поподробнее прочитать в [ubbook](https://github.com/Nekrolm/ubbook/blob/master/runtime/static_initialization_order_fiasco.md#initialization-order-fiasco-%D0%B8-%D0%BD%D0%B5%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D0%BC%D1%8B%D0%B5-%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8).

### Полезные ссылки
* https://isocpp.org/wiki/faq/ctors#static-init-order
* https://github.com/Nekrolm/ubbook/blob/master/runtime/static_initialization_order_fiasco.md
* https://en.cppreference.com/w/cpp/language/initialization</details>

